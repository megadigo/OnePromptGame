<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #game-container {
            position: relative;
            box-shadow: 0 0 40px rgba(255, 255, 0, 0.5);
        }
        
        #game-canvas {
            display: block;
            border: 3px solid #FFFF00;
            background: #000000;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="700" height="750"></canvas>
    </div>
    
    <script>
        // Game Configuration
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // Constants
        const GRID_SIZE = 20;
        const MAZE_ROWS = 29;
        const MAZE_COLS = 29;
        const OFFSET_X = 60;
        const OFFSET_Y = 70;
        
        // Game State
        let gameState = 'menu'; // 'menu', 'playing', 'levelComplete', 'gameOver'
        let lives = 3;
        let level = 1;
        let score = 0;
        let frameCount = 0;
        let levelCompleteTimer = 0;
        let ghostComboMultiplier = 1;
        
        // Input State
        const keys = {};
        let queuedDirection = null;
        
        // Player Configuration
        const pacman = {
            gridX: 14,
            gridY: 24,
            x: 0,
            y: 0,
            radius: 10,
            color: '#FFFF00',
            direction: { x: 0, y: 0 },
            nextDirection: { x: 0, y: 0 },
            moveDelay: 8,
            moveTimer: 0,
            mouthAngle: 45,
            mouthOpen: true,
            animationTimer: 0,
            animationSpeed: 8
        };
        
        // Ghost Configuration
        const ghosts = [
            { name: 'Blinky', gridX: 12, gridY: 11, color: '#FF0000', direction: { x: 1, y: 0 } },
            { name: 'Pinky', gridX: 14, gridY: 11, color: '#FFB8FF', direction: { x: -1, y: 0 } },
            { name: 'Inky', gridX: 13, gridY: 12, color: '#00FFFF', direction: { x: 0, y: -1 } },
            { name: 'Clyde', gridX: 15, gridY: 12, color: '#FFB851', direction: { x: 0, y: 1 } }
        ];
        
        ghosts.forEach(ghost => {
            ghost.x = 0;
            ghost.y = 0;
            ghost.radius = 10;
            ghost.moveDelay = 10;
            ghost.moveTimer = 0;
            ghost.frightened = false;
            ghost.frightenedTimer = 0;
            ghost.eaten = false;
        });
        
        // Maze, Pellets, and Power Pellets
        let maze = [];
        let pellets = [];
        let powerPellets = [];
        let frightenedDuration = 300;
        let powerPelletBlinkTimer = 0;
        
        // Audio (optional - will fail silently if files don't exist)
        const audio = {
            chomp: new Audio('assets/chomp.wav'),
            ghostEaten: new Audio('assets/ghost_eaten.wav'),
            pacmanDeath: new Audio('assets/pacman_death.wav'),
            powerPellet: new Audio('assets/power_pellet.wav')
        };
        
        // Initialize audio (mute errors)
        Object.values(audio).forEach(sound => {
            sound.volume = 0.3;
            sound.onerror = () => {};
        });
        
        // Generate Maze using Depth-First Search
        function generateMaze() {
            // Initialize maze with all walls
            maze = Array(MAZE_ROWS).fill(null).map(() => Array(MAZE_COLS).fill(1));
            
            // Create ghost house
            for (let y = 10; y <= 13; y++) {
                for (let x = 11; x <= 16; x++) {
                    maze[y][x] = 2; // 2 = ghost house
                }
            }
            
            // DFS maze generation
            const stack = [];
            const startX = 1;
            const startY = 1;
            maze[startY][startX] = 0;
            stack.push({ x: startX, y: startY });
            
            const directions = [
                { x: 0, y: -2 }, { x: 2, y: 0 }, { x: 0, y: 2 }, { x: -2, y: 0 }
            ];
            
            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];
                
                directions.forEach(dir => {
                    const nx = current.x + dir.x;
                    const ny = current.y + dir.y;
                    
                    if (nx > 0 && nx < MAZE_COLS - 1 && ny > 0 && ny < MAZE_ROWS - 1 && maze[ny][nx] === 1) {
                        // Check if not in ghost house
                        if (!(nx >= 11 && nx <= 16 && ny >= 10 && ny <= 13)) {
                            neighbors.push({ x: nx, y: ny, dir });
                        }
                    }
                });
                
                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    const wallX = current.x + next.dir.x / 2;
                    const wallY = current.y + next.dir.y / 2;
                    
                    maze[wallY][wallX] = 0;
                    maze[next.y][next.x] = 0;
                    stack.push({ x: next.x, y: next.y });
                } else {
                    stack.pop();
                }
            }
            
            // Ensure player and ghost spawn positions are paths
            maze[24][14] = 0; // Pacman spawn
            for (let y = 10; y <= 13; y++) {
                for (let x = 11; x <= 16; x++) {
                    maze[y][x] = 2; // Ghost house
                }
            }
            
            // Create more open paths
            for (let i = 0; i < 50; i++) {
                const x = Math.floor(Math.random() * (MAZE_COLS - 2)) + 1;
                const y = Math.floor(Math.random() * (MAZE_ROWS - 2)) + 1;
                if (!(x >= 11 && x <= 16 && y >= 10 && y <= 13)) {
                    maze[y][x] = 0;
                }
            }
        }
        
        // Place Pellets
        function placePellets() {
            pellets = [];
            for (let y = 0; y < MAZE_ROWS; y++) {
                for (let x = 0; x < MAZE_COLS; x++) {
                    if (maze[y][x] === 0) {
                        // Don't place at pacman spawn
                        if (x === 14 && y === 24) continue;
                        // Don't place too close to ghosts
                        if (x >= 11 && x <= 16 && y >= 10 && y <= 13) continue;
                        
                        pellets.push({ x, y, radius: 3, color: '#FFB897', points: 10 });
                    }
                }
            }
        }
        
        // Place Power Pellets
        function placePowerPellets() {
            powerPellets = [];
            const corners = [
                { x: 1, y: 1 },
                { x: MAZE_COLS - 2, y: 1 },
                { x: 1, y: MAZE_ROWS - 2 },
                { x: MAZE_COLS - 2, y: MAZE_ROWS - 2 }
            ];
            
            corners.forEach(corner => {
                // Find nearest path cell
                let found = false;
                for (let radius = 0; radius <= 8 && !found; radius++) {
                    for (let dy = -radius; dy <= radius && !found; dy++) {
                        for (let dx = -radius; dx <= radius && !found; dx++) {
                            const nx = corner.x + dx;
                            const ny = corner.y + dy;
                            if (nx >= 0 && nx < MAZE_COLS && ny >= 0 && ny < MAZE_ROWS && maze[ny][nx] === 0) {
                                powerPellets.push({ x: nx, y: ny, radius: 8, color: '#FFB897', points: 50 });
                                // Remove regular pellet if exists
                                pellets = pellets.filter(p => !(p.x === nx && p.y === ny));
                                found = true;
                            }
                        }
                    }
                }
            });
        }
        
        // Initialize Game
        function initGame() {
            lives = 3;
            level = 1;
            score = 0;
            gameState = 'menu';
            frightenedDuration = 300;
            initLevel();
        }
        
        // Initialize Level
        function initLevel() {
            generateMaze();
            placePellets();
            placePowerPellets();
            
            // Reset Pacman
            pacman.gridX = 14;
            pacman.gridY = 24;
            pacman.direction = { x: 0, y: 0 };
            pacman.nextDirection = { x: 0, y: 0 };
            updatePixelPosition(pacman);
            
            // Reset Ghosts
            const spawns = [
                { gridX: 12, gridY: 11 },
                { gridX: 14, gridY: 11 },
                { gridX: 13, gridY: 12 },
                { gridX: 15, gridY: 12 }
            ];
            ghosts.forEach((ghost, i) => {
                ghost.gridX = spawns[i].gridX;
                ghost.gridY = spawns[i].gridY;
                ghost.direction = { x: Math.random() > 0.5 ? 1 : -1, y: 0 };
                ghost.frightened = false;
                ghost.frightenedTimer = 0;
                ghost.eaten = false;
                updatePixelPosition(ghost);
            });
            
            ghostComboMultiplier = 1;
        }
        
        // Update pixel position from grid position
        function updatePixelPosition(entity) {
            entity.x = OFFSET_X + entity.gridX * GRID_SIZE + GRID_SIZE / 2;
            entity.y = OFFSET_Y + entity.gridY * GRID_SIZE + GRID_SIZE / 2;
        }
        
        // Keyboard Input
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            if (gameState === 'menu' && e.code === 'Space') {
                gameState = 'playing';
                initLevel();
            }
            
            if (gameState === 'gameOver' && e.code === 'KeyR') {
                initGame();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // Check if position is valid
        function isValidMove(gridX, gridY) {
            if (gridX < 0 || gridX >= MAZE_COLS || gridY < 0 || gridY >= MAZE_ROWS) return false;
            return maze[gridY][gridX] !== 1;
        }
        
        // Update Pacman
        function updatePacman() {
            // Handle input
            if (keys['KeyW'] || keys['ArrowUp']) {
                pacman.nextDirection = { x: 0, y: -1 };
            } else if (keys['KeyS'] || keys['ArrowDown']) {
                pacman.nextDirection = { x: 0, y: 1 };
            } else if (keys['KeyA'] || keys['ArrowLeft']) {
                pacman.nextDirection = { x: -1, y: 0 };
            } else if (keys['KeyD'] || keys['ArrowRight']) {
                pacman.nextDirection = { x: 1, y: 0 };
            }
            
            // Movement
            pacman.moveTimer++;
            if (pacman.moveTimer >= pacman.moveDelay) {
                pacman.moveTimer = 0;
                
                // Try next direction first
                const nextX = pacman.gridX + pacman.nextDirection.x;
                const nextY = pacman.gridY + pacman.nextDirection.y;
                
                if (isValidMove(nextX, nextY)) {
                    pacman.direction = { ...pacman.nextDirection };
                }
                
                // Move in current direction
                const newX = pacman.gridX + pacman.direction.x;
                const newY = pacman.gridY + pacman.direction.y;
                
                if (isValidMove(newX, newY)) {
                    pacman.gridX = newX;
                    pacman.gridY = newY;
                    updatePixelPosition(pacman);
                }
            }
            
            // Animation
            pacman.animationTimer++;
            if (pacman.animationTimer >= pacman.animationSpeed) {
                pacman.animationTimer = 0;
                pacman.mouthOpen = !pacman.mouthOpen;
            }
            
            // Collect pellets
            pellets = pellets.filter(pellet => {
                if (pellet.x === pacman.gridX && pellet.y === pacman.gridY) {
                    score += pellet.points;
                    try { audio.chomp.play(); } catch(e) {}
                    return false;
                }
                return true;
            });
            
            // Collect power pellets
            powerPellets = powerPellets.filter(pellet => {
                if (pellet.x === pacman.gridX && pellet.y === pacman.gridY) {
                    score += pellet.points;
                    ghostComboMultiplier = 1;
                    ghosts.forEach(ghost => {
                        if (!ghost.eaten) {
                            ghost.frightened = true;
                            ghost.frightenedTimer = frightenedDuration;
                        }
                    });
                    try { audio.powerPellet.play(); } catch(e) {}
                    return false;
                }
                return true;
            });
            
            // Check level complete
            if (pellets.length === 0 && powerPellets.length === 0) {
                gameState = 'levelComplete';
                levelCompleteTimer = 0;
            }
        }
        
        // Update Ghosts
        function updateGhosts() {
            ghosts.forEach(ghost => {
                if (ghost.eaten) return;
                
                // Update frightened state
                if (ghost.frightened) {
                    ghost.frightenedTimer--;
                    if (ghost.frightenedTimer <= 0) {
                        ghost.frightened = false;
                    }
                }
                
                // Movement
                const delay = ghost.frightened ? 12 : ghost.moveDelay;
                ghost.moveTimer++;
                
                if (ghost.moveTimer >= delay) {
                    ghost.moveTimer = 0;
                    
                    // Get possible directions
                    const possibleDirs = [];
                    const dirs = [
                        { x: 0, y: -1 },
                        { x: 0, y: 1 },
                        { x: -1, y: 0 },
                        { x: 1, y: 0 }
                    ];
                    
                    dirs.forEach(dir => {
                        const newX = ghost.gridX + dir.x;
                        const newY = ghost.gridY + dir.y;
                        if (isValidMove(newX, newY)) {
                            // Avoid backtracking
                            if (!(dir.x === -ghost.direction.x && dir.y === -ghost.direction.y)) {
                                possibleDirs.push(dir);
                            }
                        }
                    });
                    
                    if (possibleDirs.length === 0) {
                        // If stuck, allow backtracking
                        dirs.forEach(dir => {
                            const newX = ghost.gridX + dir.x;
                            const newY = ghost.gridY + dir.y;
                            if (isValidMove(newX, newY)) {
                                possibleDirs.push(dir);
                            }
                        });
                    }
                    
                    if (possibleDirs.length > 0) {
                        let chosenDir;
                        
                        if (ghost.frightened) {
                            // Random movement when frightened
                            chosenDir = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                        } else {
                            // 70% chase, 30% random
                            if (Math.random() < 0.7) {
                                // Chase pacman - choose direction that reduces distance
                                let bestDir = possibleDirs[0];
                                let bestDist = Infinity;
                                
                                possibleDirs.forEach(dir => {
                                    const newX = ghost.gridX + dir.x;
                                    const newY = ghost.gridY + dir.y;
                                    const dist = Math.abs(newX - pacman.gridX) + Math.abs(newY - pacman.gridY);
                                    if (dist < bestDist) {
                                        bestDist = dist;
                                        bestDir = dir;
                                    }
                                });
                                
                                chosenDir = bestDir;
                            } else {
                                // Random movement
                                chosenDir = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                            }
                        }
                        
                        ghost.direction = chosenDir;
                        ghost.gridX += chosenDir.x;
                        ghost.gridY += chosenDir.y;
                        updatePixelPosition(ghost);
                    }
                }
            });
            
            // Check collisions
            ghosts.forEach(ghost => {
                if (ghost.eaten) return;
                
                const dist = Math.sqrt(
                    Math.pow(ghost.x - pacman.x, 2) + 
                    Math.pow(ghost.y - pacman.y, 2)
                );
                
                if (dist < 20) {
                    if (ghost.frightened) {
                        // Eat ghost
                        score += 200 * ghostComboMultiplier;
                        ghostComboMultiplier *= 2;
                        ghost.eaten = true;
                        ghost.frightened = false;
                        try { audio.ghostEaten.play(); } catch(e) {}
                        
                        // Respawn after delay
                        setTimeout(() => {
                            ghost.eaten = false;
                            ghost.gridX = 14;
                            ghost.gridY = 11;
                            updatePixelPosition(ghost);
                        }, 2000);
                    } else {
                        // Lose life
                        lives--;
                        try { audio.pacmanDeath.play(); } catch(e) {}
                        
                        if (lives <= 0) {
                            gameState = 'gameOver';
                        } else {
                            // Reset positions
                            pacman.gridX = 14;
                            pacman.gridY = 24;
                            pacman.direction = { x: 0, y: 0 };
                            updatePixelPosition(pacman);
                            
                            const spawns = [
                                { gridX: 12, gridY: 11 },
                                { gridX: 14, gridY: 11 },
                                { gridX: 13, gridY: 12 },
                                { gridX: 15, gridY: 12 }
                            ];
                            ghosts.forEach((g, i) => {
                                g.gridX = spawns[i].gridX;
                                g.gridY = spawns[i].gridY;
                                g.frightened = false;
                                g.eaten = false;
                                updatePixelPosition(g);
                            });
                        }
                    }
                }
            });
        }
        
        // Render Maze
        function renderMaze() {
            ctx.fillStyle = '#0000FF';
            for (let y = 0; y < MAZE_ROWS; y++) {
                for (let x = 0; x < MAZE_COLS; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillRect(
                            OFFSET_X + x * GRID_SIZE,
                            OFFSET_Y + y * GRID_SIZE,
                            GRID_SIZE,
                            GRID_SIZE
                        );
                    } else if (maze[y][x] === 2) {
                        ctx.fillStyle = '#1a0033';
                        ctx.fillRect(
                            OFFSET_X + x * GRID_SIZE,
                            OFFSET_Y + y * GRID_SIZE,
                            GRID_SIZE,
                            GRID_SIZE
                        );
                        ctx.fillStyle = '#0000FF';
                    }
                }
            }
        }
        
        // Render Pellets
        function renderPellets() {
            pellets.forEach(pellet => {
                ctx.fillStyle = pellet.color;
                ctx.beginPath();
                ctx.arc(
                    OFFSET_X + pellet.x * GRID_SIZE + GRID_SIZE / 2,
                    OFFSET_Y + pellet.y * GRID_SIZE + GRID_SIZE / 2,
                    pellet.radius,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            });
            
            // Power pellets with blinking
            powerPelletBlinkTimer++;
            const showPowerPellets = Math.floor(powerPelletBlinkTimer / 15) % 2 === 0;
            
            if (showPowerPellets) {
                powerPellets.forEach(pellet => {
                    ctx.fillStyle = pellet.color;
                    ctx.beginPath();
                    ctx.arc(
                        OFFSET_X + pellet.x * GRID_SIZE + GRID_SIZE / 2,
                        OFFSET_Y + pellet.y * GRID_SIZE + GRID_SIZE / 2,
                        pellet.radius,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                });
            }
        }
        
        // Render Pacman
        function renderPacman() {
            ctx.fillStyle = pacman.color;
            ctx.beginPath();
            
            const mouthAngle = pacman.mouthOpen ? pacman.mouthAngle : 0;
            const angleRad = mouthAngle * Math.PI / 180;
            
            // Determine start angle based on direction
            let startAngle = angleRad / 2;
            if (pacman.direction.x === 1) startAngle = angleRad / 2;
            else if (pacman.direction.x === -1) startAngle = Math.PI - angleRad / 2;
            else if (pacman.direction.y === -1) startAngle = -Math.PI / 2 + angleRad / 2;
            else if (pacman.direction.y === 1) startAngle = Math.PI / 2 + angleRad / 2;
            
            const endAngle = startAngle + (Math.PI * 2 - angleRad);
            
            ctx.arc(pacman.x, pacman.y, pacman.radius, startAngle, endAngle);
            ctx.lineTo(pacman.x, pacman.y);
            ctx.fill();
        }
        
        // Render Ghosts
        function renderGhosts() {
            ghosts.forEach(ghost => {
                if (ghost.eaten) return;
                
                const color = ghost.frightened ? '#0000FF' : ghost.color;
                ctx.fillStyle = color;
                
                // Ghost body
                ctx.beginPath();
                ctx.arc(ghost.x, ghost.y - 3, ghost.radius, Math.PI, 0, false);
                ctx.lineTo(ghost.x + ghost.radius, ghost.y + ghost.radius);
                ctx.lineTo(ghost.x + ghost.radius - 4, ghost.y + ghost.radius - 4);
                ctx.lineTo(ghost.x + ghost.radius - 8, ghost.y + ghost.radius);
                ctx.lineTo(ghost.x, ghost.y + ghost.radius - 4);
                ctx.lineTo(ghost.x - ghost.radius + 8, ghost.y + ghost.radius);
                ctx.lineTo(ghost.x - ghost.radius + 4, ghost.y + ghost.radius - 4);
                ctx.lineTo(ghost.x - ghost.radius, ghost.y + ghost.radius);
                ctx.closePath();
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(ghost.x - 4, ghost.y - 2, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(ghost.x + 4, ghost.y - 2, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(ghost.x - 4, ghost.y - 2, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(ghost.x + 4, ghost.y - 2, 1.5, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Render UI
        function renderUI() {
            ctx.textAlign = 'left';
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 24px Arial';
            ctx.fillText(`Lives: ${lives}`, 30, 30);
            
            ctx.textAlign = 'right';
            ctx.fillStyle = '#00FFFF';
            ctx.fillText(`Level: ${level}`, 670, 30);
            
            ctx.textAlign = 'center';
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('PAC-MAN', 350, 30);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = 'bold 24px Arial';
            ctx.fillText(`Score: ${score}`, 350, 735);
        }
        
        // Render Menu
        function renderMenu() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.textAlign = 'center';
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 60px Arial';
            ctx.fillText('PAC-MAN', 350, 200);
            
            ctx.fillStyle = '#CCCCCC';
            ctx.font = '22px Arial';
            ctx.fillText('AI-Generated Game', 350, 250);
            
            ctx.fillStyle = '#FFB8FF';
            ctx.font = 'bold 30px Arial';
            ctx.fillText('Press SPACE to Start', 350, 350);
            
            ctx.fillStyle = '#00FFFF';
            ctx.font = '20px Arial';
            ctx.fillText('Controls: WASD or Arrow Keys', 350, 430);
            
            ctx.fillStyle = '#FF0000';
            ctx.fillText('Eat all pellets! Avoid ghosts!', 350, 470);
            
            ctx.fillStyle = '#FFB851';
            ctx.fillText('Power pellets let you eat ghosts!', 350, 510);
        }
        
        // Render Level Complete
        function renderLevelComplete() {
            ctx.textAlign = 'center';
            ctx.fillStyle = '#00FF00';
            ctx.font = 'bold 45px Arial';
            ctx.fillText('LEVEL COMPLETE!', 350, 320);
            
            ctx.fillStyle = '#FFFF00';
            ctx.font = '32px Arial';
            ctx.fillText(`Get Ready for Level ${level + 1}!`, 350, 400);
        }
        
        // Render Game Over
        function renderGameOver() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.textAlign = 'center';
            ctx.fillStyle = '#FF0000';
            ctx.font = 'bold 60px Arial';
            ctx.fillText('GAME OVER', 350, 280);
            
            ctx.fillStyle = '#FFFF00';
            ctx.font = '32px Arial';
            ctx.fillText(`Final Level: ${level}`, 350, 350);
            ctx.fillText(`Final Score: ${score}`, 350, 395);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = '24px Arial';
            ctx.fillText('Press R to Restart', 350, 470);
            
            ctx.fillStyle = '#FFB8FF';
            ctx.font = '20px Arial';
            let message = 'Nice try! Practice makes perfect!';
            if (level >= 10) message = "Incredible! You're a Pac-Man master!";
            else if (level >= 5) message = "Excellent! You're really good at this!";
            ctx.fillText(message, 350, 550);
        }
        
        // Game Loop
        function gameLoop() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (gameState === 'menu') {
                renderMenu();
            } else if (gameState === 'playing') {
                updatePacman();
                updateGhosts();
                
                renderMaze();
                renderPellets();
                renderPacman();
                renderGhosts();
                renderUI();
            } else if (gameState === 'levelComplete') {
                renderMaze();
                renderPellets();
                renderPacman();
                renderGhosts();
                renderUI();
                renderLevelComplete();
                
                levelCompleteTimer++;
                if (levelCompleteTimer >= 120) {
                    level++;
                    // Increase difficulty
                    ghosts.forEach(ghost => {
                        ghost.moveDelay = Math.max(6, ghost.moveDelay - 0.5);
                    });
                    frightenedDuration = Math.max(120, frightenedDuration - 20);
                    
                    initLevel();
                    gameState = 'playing';
                }
            } else if (gameState === 'gameOver') {
                renderGameOver();
            }
            
            frameCount++;
            requestAnimationFrame(gameLoop);
        }
        
        // Start Game
        initGame();
        gameLoop();
    </script>
</body>
</html>