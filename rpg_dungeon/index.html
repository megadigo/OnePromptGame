<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG Dungeon</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #2C1810 0%, #1a0f0a 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #game-container {
            position: relative;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.5);
        }
        
        #game-canvas {
            display: block;
            border: 3px solid #FFD700;
            background: #000000;
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="1000" height="700"></canvas>
    </div>
    
    <script>
        // Game Configuration
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // Constants
        const GRID_SIZE = 40;
        const DUNGEON_ROWS = 15;
        const DUNGEON_COLS = 20;
        const OFFSET_X = 20;
        const OFFSET_Y = 50;
        const MAX_FLOOR = 10;
        
        // Game State
        let gameState = 'menu'; // 'menu', 'playing', 'levelUp', 'victory', 'gameOver'
        let floor = 1;
        let frameCount = 0;
        let levelUpTimer = 0;
        
        // Input State
        const keys = {};
        let mouseX = 0;
        let mouseY = 0;
        
        // Player
        const player = {
            x: 0,
            y: 0,
            radius: 15,
            color: '#00FF00',
            speed: 3,
            health: 100,
            maxHealth: 100,
            attack: 10,
            defense: 5,
            level: 1,
            experience: 0,
            experienceNeeded: 100,
            gold: 0,
            potions: 3,
            keys: 0,
            attackCooldown: 30,
            attackTimer: 0,
            direction: 0
        };
        
        // Game Objects
        let dungeon = [];
        let enemies = [];
        let items = [];
        let chests = [];
        let doors = [];
        let projectiles = [];
        let enemyProjectiles = [];
        let exitStairs = null;
        let particles = [];
        
        // Enemy Templates
        const enemyTypes = {
            slime: {
                name: 'Slime',
                shape: 'circle',
                radius: 12,
                color: '#00FF00',
                health: 30,
                attack: 5,
                defense: 2,
                speed: 1,
                expValue: 20,
                goldMin: 5,
                goldMax: 15
            },
            skeleton: {
                name: 'Skeleton',
                shape: 'square',
                width: 20,
                height: 20,
                color: '#CCCCCC',
                health: 50,
                attack: 8,
                defense: 4,
                speed: 1.5,
                expValue: 35,
                goldMin: 10,
                goldMax: 25
            },
            orc: {
                name: 'Orc',
                shape: 'square',
                width: 25,
                height: 25,
                color: '#228B22',
                health: 80,
                attack: 12,
                defense: 6,
                speed: 1.2,
                expValue: 50,
                goldMin: 20,
                goldMax: 40
            }
        };
        
        // Initialize Game
        function initGame() {
            floor = 1;
            player.health = 100;
            player.maxHealth = 100;
            player.attack = 10;
            player.defense = 5;
            player.level = 1;
            player.experience = 0;
            player.experienceNeeded = 100;
            player.gold = 0;
            player.potions = 3;
            player.keys = 0;
            gameState = 'menu';
        }
        
        // Generate Dungeon using BSP
        function generateDungeon() {
            // Initialize with walls
            dungeon = Array(DUNGEON_ROWS).fill(null).map(() => Array(DUNGEON_COLS).fill(1));
            
            const rooms = [];
            
            // Generate rooms
            const numRooms = 6 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numRooms; i++) {
                const width = 3 + Math.floor(Math.random() * 5);
                const height = 3 + Math.floor(Math.random() * 5);
                const x = 1 + Math.floor(Math.random() * (DUNGEON_COLS - width - 2));
                const y = 1 + Math.floor(Math.random() * (DUNGEON_ROWS - height - 2));
                
                // Check overlap
                let overlap = false;
                for (const room of rooms) {
                    if (x < room.x + room.width + 1 && x + width + 1 > room.x &&
                        y < room.y + room.height + 1 && y + height + 1 > room.y) {
                        overlap = true;
                        break;
                    }
                }
                
                if (!overlap) {
                    rooms.push({ x, y, width, height });
                    
                    // Carve room
                    for (let ry = y; ry < y + height; ry++) {
                        for (let rx = x; rx < x + width; rx++) {
                            dungeon[ry][rx] = 0;
                        }
                    }
                }
            }
            
            // Connect rooms with corridors
            for (let i = 0; i < rooms.length - 1; i++) {
                const room1 = rooms[i];
                const room2 = rooms[i + 1];
                
                const x1 = Math.floor(room1.x + room1.width / 2);
                const y1 = Math.floor(room1.y + room1.height / 2);
                const x2 = Math.floor(room2.x + room2.width / 2);
                const y2 = Math.floor(room2.y + room2.height / 2);
                
                // Horizontal corridor
                const startX = Math.min(x1, x2);
                const endX = Math.max(x1, x2);
                for (let x = startX; x <= endX; x++) {
                    if (y1 >= 0 && y1 < DUNGEON_ROWS && x >= 0 && x < DUNGEON_COLS) {
                        dungeon[y1][x] = 0;
                    }
                }
                
                // Vertical corridor
                const startY = Math.min(y1, y2);
                const endY = Math.max(y1, y2);
                for (let y = startY; y <= endY; y++) {
                    if (y >= 0 && y < DUNGEON_ROWS && x2 >= 0 && x2 < DUNGEON_COLS) {
                        dungeon[y][x2] = 0;
                    }
                }
            }
            
            return rooms;
        }
        
        // Initialize Level
        function initLevel() {
            const rooms = generateDungeon();
            enemies = [];
            items = [];
            chests = [];
            doors = [];
            projectiles = [];
            enemyProjectiles = [];
            exitStairs = null;
            particles = [];
            
            // Spawn player in first room
            const spawnRoom = rooms[0];
            player.x = OFFSET_X + (spawnRoom.x + Math.floor(spawnRoom.width / 2)) * GRID_SIZE;
            player.y = OFFSET_Y + (spawnRoom.y + Math.floor(spawnRoom.height / 2)) * GRID_SIZE;
            player.attackTimer = 0;
            
            // Spawn enemies in other rooms
            const difficultyMultiplier = 1 + (floor - 1) * 0.2;
            for (let i = 1; i < rooms.length - 1; i++) {
                const room = rooms[i];
                const enemyCount = 1 + Math.floor(Math.random() * 3);
                
                for (let j = 0; j < enemyCount; j++) {
                    const typeRoll = Math.random();
                    let type;
                    if (typeRoll < 0.5) type = 'slime';
                    else if (typeRoll < 0.8) type = 'skeleton';
                    else type = 'orc';
                    
                    const template = enemyTypes[type];
                    const enemy = {
                        type: type,
                        shape: template.shape,
                        radius: template.radius || 0,
                        width: template.width || 0,
                        height: template.height || 0,
                        color: template.color,
                        x: OFFSET_X + (room.x + 1 + Math.random() * (room.width - 2)) * GRID_SIZE,
                        y: OFFSET_Y + (room.y + 1 + Math.random() * (room.height - 2)) * GRID_SIZE,
                        maxHealth: Math.floor(template.health * difficultyMultiplier),
                        health: Math.floor(template.health * difficultyMultiplier),
                        attack: Math.floor(template.attack * Math.pow(1.15, floor - 1)),
                        defense: template.defense,
                        speed: template.speed,
                        expValue: template.expValue,
                        goldMin: template.goldMin,
                        goldMax: template.goldMax,
                        attackCooldown: 60,
                        attackTimer: 0,
                        detectionRange: 200,
                        attackRange: 30
                    };
                    enemies.push(enemy);
                }
            }
            
            // Spawn chests
            const chestCount = 2 + Math.floor(Math.random() * 3);
            for (let i = 0; i < chestCount && i < rooms.length - 1; i++) {
                const room = rooms[1 + i];
                chests.push({
                    x: OFFSET_X + (room.x + Math.floor(room.width / 2)) * GRID_SIZE,
                    y: OFFSET_Y + (room.y + Math.floor(room.height / 2)) * GRID_SIZE,
                    width: 20,
                    height: 15,
                    color: '#8B4513',
                    opened: false,
                    gold: 30 + Math.floor(Math.random() * 71)
                });
            }
            
            // Spawn health potions
            for (let i = 0; i < 2; i++) {
                if (Math.random() < 0.5 && i + 2 < rooms.length) {
                    const room = rooms[i + 2];
                    items.push({
                        type: 'potion',
                        x: OFFSET_X + (room.x + Math.random() * room.width) * GRID_SIZE,
                        y: OFFSET_Y + (room.y + Math.random() * room.height) * GRID_SIZE,
                        radius: 8,
                        color: '#FF0000'
                    });
                }
            }
            
            // Place doors
            for (let i = 0; i < 3 && i < rooms.length; i++) {
                const room = rooms[i];
                doors.push({
                    x: OFFSET_X + (room.x + room.width) * GRID_SIZE,
                    y: OFFSET_Y + (room.y + Math.floor(room.height / 2)) * GRID_SIZE,
                    width: 10,
                    height: GRID_SIZE,
                    color: '#8B4513',
                    locked: true
                });
                
                // Spawn key
                if (i + 1 < rooms.length) {
                    const keyRoom = rooms[i + 1];
                    items.push({
                        type: 'key',
                        x: OFFSET_X + (keyRoom.x + Math.random() * keyRoom.width) * GRID_SIZE,
                        y: OFFSET_Y + (keyRoom.y + Math.random() * keyRoom.height) * GRID_SIZE,
                        radius: 6,
                        color: '#FFD700'
                    });
                }
            }
        }
        
        // Spawn Exit Stairs
        function spawnExitStairs() {
            // Find farthest room from player
            let maxDist = 0;
            let exitRoom = null;
            
            for (let y = 0; y < DUNGEON_ROWS; y++) {
                for (let x = 0; x < DUNGEON_COLS; x++) {
                    if (dungeon[y][x] === 0) {
                        const px = OFFSET_X + x * GRID_SIZE;
                        const py = OFFSET_Y + y * GRID_SIZE;
                        const dist = Math.sqrt(Math.pow(px - player.x, 2) + Math.pow(py - player.y, 2));
                        if (dist > maxDist) {
                            maxDist = dist;
                            exitRoom = { x: px, y: py };
                        }
                    }
                }
            }
            
            if (exitRoom) {
                exitStairs = {
                    x: exitRoom.x,
                    y: exitRoom.y,
                    width: 30,
                    height: 30,
                    color: '#FFD700'
                };
            }
        }
        
        // Keyboard Input
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            if (gameState === 'menu' && e.code === 'Space') {
                gameState = 'playing';
                initLevel();
            }
            
            if ((gameState === 'gameOver' || gameState === 'victory') && e.code === 'KeyR') {
                initGame();
            }
            
            if (gameState === 'playing') {
                if (e.code === 'KeyE') {
                    // Use potion
                    if (player.potions > 0 && player.health < player.maxHealth) {
                        player.potions--;
                        player.health = Math.min(player.maxHealth, player.health + 50);
                        createParticles(player.x, player.y, '#FF0000', 10);
                    }
                }
                
                if (e.code === 'KeyQ') {
                    // Interact with chests
                    chests.forEach(chest => {
                        if (!chest.opened) {
                            const dist = Math.sqrt(Math.pow(chest.x - player.x, 2) + Math.pow(chest.y - player.y, 2));
                            if (dist < 40) {
                                chest.opened = true;
                                player.gold += chest.gold;
                                if (Math.random() < 0.5) {
                                    player.potions++;
                                }
                                createParticles(chest.x, chest.y, '#FFD700', 15);
                            }
                        }
                    });
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // Mouse Input
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        
        canvas.addEventListener('click', (e) => {
            if (gameState === 'playing' && player.attackTimer === 0) {
                const rect = canvas.getBoundingClientRect();
                const targetX = e.clientX - rect.left;
                const targetY = e.clientY - rect.top;
                
                // Shoot projectile
                const angle = Math.atan2(targetY - player.y, targetX - player.x);
                projectiles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * 8,
                    vy: Math.sin(angle) * 8,
                    radius: 5,
                    color: '#FFFF00',
                    lifetime: 30,
                    damage: player.attack
                });
                
                player.attackTimer = player.attackCooldown;
            }
        });
        
        // Check collision with dungeon
        function isWall(x, y) {
            const gridX = Math.floor((x - OFFSET_X) / GRID_SIZE);
            const gridY = Math.floor((y - OFFSET_Y) / GRID_SIZE);
            
            if (gridX < 0 || gridX >= DUNGEON_COLS || gridY < 0 || gridY >= DUNGEON_ROWS) {
                return true;
            }
            
            return dungeon[gridY][gridX] === 1;
        }
        
        // Create particles
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    color: color,
                    lifetime: 30,
                    radius: 3
                });
            }
        }
        
        // Update Player
        function updatePlayer() {
            let dx = 0;
            let dy = 0;
            
            if (keys['KeyW'] || keys['ArrowUp']) dy -= 1;
            if (keys['KeyS'] || keys['ArrowDown']) dy += 1;
            if (keys['KeyA'] || keys['ArrowLeft']) dx -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) dx += 1;
            
            // Normalize diagonal movement
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }
            
            // Calculate direction for rendering
            if (dx !== 0 || dy !== 0) {
                player.direction = Math.atan2(dy, dx);
            } else {
                // Face mouse when not moving
                player.direction = Math.atan2(mouseY - player.y, mouseX - player.x);
            }
            
            // Try to move
            const newX = player.x + dx * player.speed;
            const newY = player.y + dy * player.speed;
            
            // Check collisions
            const checkPoints = [
                { x: newX, y: newY },
                { x: newX + player.radius, y: newY },
                { x: newX - player.radius, y: newY },
                { x: newX, y: newY + player.radius },
                { x: newX, y: newY - player.radius }
            ];
            
            let canMoveX = true;
            let canMoveY = true;
            
            for (const point of checkPoints) {
                if (isWall(point.x, player.y)) canMoveX = false;
                if (isWall(player.x, point.y)) canMoveY = false;
            }
            
            if (canMoveX) player.x = newX;
            if (canMoveY) player.y = newY;
            
            // Attack cooldown
            if (player.attackTimer > 0) {
                player.attackTimer--;
            }
            
            // Collect items
            items = items.filter(item => {
                const dist = Math.sqrt(Math.pow(item.x - player.x, 2) + Math.pow(item.y - player.y, 2));
                if (dist < 25) {
                    if (item.type === 'potion') {
                        player.potions++;
                    } else if (item.type === 'key') {
                        player.keys++;
                    }
                    createParticles(item.x, item.y, item.color, 8);
                    return false;
                }
                return true;
            });
            
            // Unlock doors
            doors = doors.filter(door => {
                if (door.locked && player.keys > 0) {
                    const dist = Math.sqrt(Math.pow(door.x - player.x, 2) + Math.pow(door.y - player.y, 2));
                    if (dist < 40) {
                        player.keys--;
                        createParticles(door.x, door.y, '#FFD700', 10);
                        return false;
                    }
                }
                return true;
            });
            
            // Check exit stairs
            if (exitStairs) {
                const dist = Math.sqrt(Math.pow(exitStairs.x - player.x, 2) + Math.pow(exitStairs.y - player.y, 2));
                if (dist < 40) {
                    if (floor >= MAX_FLOOR) {
                        gameState = 'victory';
                    } else {
                        floor++;
                        initLevel();
                    }
                }
            }
        }
        
        // Update Enemies
        function updateEnemies() {
            enemies.forEach(enemy => {
                // AI: Chase player if in range
                const dist = Math.sqrt(Math.pow(enemy.x - player.x, 2) + Math.pow(enemy.y - player.y, 2));
                
                if (dist < enemy.detectionRange) {
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    const newX = enemy.x + Math.cos(angle) * enemy.speed;
                    const newY = enemy.y + Math.sin(angle) * enemy.speed;
                    
                    if (!isWall(newX, enemy.y)) enemy.x = newX;
                    if (!isWall(enemy.x, newY)) enemy.y = newY;
                    
                    // Attack
                    enemy.attackTimer++;
                    if (enemy.attackTimer >= enemy.attackCooldown && dist < enemy.attackRange) {
                        const damage = Math.max(1, enemy.attack - player.defense);
                        player.health -= damage;
                        enemy.attackTimer = 0;
                        createParticles(player.x, player.y, '#FF0000', 5);
                        
                        if (player.health <= 0) {
                            gameState = 'gameOver';
                        }
                    }
                    
                    // Ranged attack for some enemies
                    if (enemy.type === 'skeleton' && dist > 100 && dist < 200 && enemy.attackTimer === 0) {
                        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemyProjectiles.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: Math.cos(angle) * 5,
                            vy: Math.sin(angle) * 5,
                            radius: 5,
                            color: '#FF0000',
                            lifetime: 30,
                            damage: enemy.attack
                        });
                        enemy.attackTimer = 0;
                    }
                }
            });
            
            // Check if all enemies defeated
            if (enemies.length === 0 && !exitStairs) {
                spawnExitStairs();
            }
        }
        
        // Update Projectiles
        function updateProjectiles() {
            // Player projectiles
            projectiles = projectiles.filter(proj => {
                proj.x += proj.vx;
                proj.y += proj.vy;
                proj.lifetime--;
                
                if (proj.lifetime <= 0 || isWall(proj.x, proj.y)) {
                    return false;
                }
                
                // Check enemy collision
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const dist = Math.sqrt(Math.pow(enemy.x - proj.x, 2) + Math.pow(enemy.y - proj.y, 2));
                    const hitRadius = enemy.radius || Math.max(enemy.width, enemy.height) / 2;
                    
                    if (dist < hitRadius + proj.radius) {
                        const damage = Math.max(1, proj.damage - enemy.defense);
                        enemy.health -= damage;
                        createParticles(enemy.x, enemy.y, enemy.color, 8);
                        
                        if (enemy.health <= 0) {
                            // Enemy defeated
                            player.experience += enemy.expValue;
                            player.gold += enemy.goldMin + Math.floor(Math.random() * (enemy.goldMax - enemy.goldMin + 1));
                            createParticles(enemy.x, enemy.y, '#FFD700', 15);
                            enemies.splice(i, 1);
                            
                            // Check level up
                            if (player.experience >= player.experienceNeeded) {
                                player.level++;
                                player.experience -= player.experienceNeeded;
                                player.experienceNeeded = player.level * 100;
                                player.maxHealth += 10;
                                player.health = player.maxHealth;
                                player.attack += 2;
                                player.defense += 1;
                                gameState = 'levelUp';
                                levelUpTimer = 0;
                            }
                        }
                        
                        return false;
                    }
                }
                
                return true;
            });
            
            // Enemy projectiles
            enemyProjectiles = enemyProjectiles.filter(proj => {
                proj.x += proj.vx;
                proj.y += proj.vy;
                proj.lifetime--;
                
                if (proj.lifetime <= 0 || isWall(proj.x, proj.y)) {
                    return false;
                }
                
                // Check player collision
                const dist = Math.sqrt(Math.pow(player.x - proj.x, 2) + Math.pow(player.y - proj.y, 2));
                if (dist < player.radius + proj.radius) {
                    const damage = Math.max(1, proj.damage - player.defense);
                    player.health -= damage;
                    createParticles(player.x, player.y, '#FF0000', 5);
                    
                    if (player.health <= 0) {
                        gameState = 'gameOver';
                    }
                    
                    return false;
                }
                
                return true;
            });
        }
        
        // Update Particles
        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.lifetime--;
                return p.lifetime > 0;
            });
        }
        
        // Render Dungeon
        function renderDungeon() {
            for (let y = 0; y < DUNGEON_ROWS; y++) {
                for (let x = 0; x < DUNGEON_COLS; x++) {
                    const px = OFFSET_X + x * GRID_SIZE;
                    const py = OFFSET_Y + y * GRID_SIZE;
                    
                    if (dungeon[y][x] === 1) {
                        ctx.fillStyle = '#2C1810';
                    } else {
                        ctx.fillStyle = '#4A3728';
                    }
                    
                    ctx.fillRect(px, py, GRID_SIZE, GRID_SIZE);
                }
            }
        }
        
        // Render Player
        function renderPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.direction);
            
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.moveTo(player.radius, 0);
            ctx.lineTo(-player.radius, player.radius);
            ctx.lineTo(-player.radius, -player.radius);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
            
            // Health bar
            renderHealthBar(player.x, player.y - 25, player.health, player.maxHealth, 30);
        }
        
        // Render Health Bar
        function renderHealthBar(x, y, health, maxHealth, width) {
            const barHeight = 5;
            const percent = health / maxHealth;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(x - width / 2, y, width, barHeight);
            
            ctx.fillStyle = percent > 0.5 ? '#00FF00' : percent > 0.25 ? '#FFFF00' : '#FF0000';
            ctx.fillRect(x - width / 2, y, width * percent, barHeight);
            
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1;
            ctx.strokeRect(x - width / 2, y, width, barHeight);
        }
        
        // Render Enemies
        function renderEnemies() {
            enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;
                
                if (enemy.shape === 'circle') {
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillRect(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2, enemy.width, enemy.height);
                }
                
                // Health bar
                renderHealthBar(enemy.x, enemy.y - 20, enemy.health, enemy.maxHealth, 25);
            });
        }
        
        // Render Items
        function renderItems() {
            items.forEach(item => {
                ctx.fillStyle = item.color;
                ctx.beginPath();
                ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Glow effect
                ctx.strokeStyle = item.color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(item.x, item.y, item.radius + 3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            });
        }
        
        // Render Chests
        function renderChests() {
            chests.forEach(chest => {
                if (!chest.opened) {
                    ctx.fillStyle = chest.color;
                    ctx.fillRect(chest.x - chest.width / 2, chest.y - chest.height / 2, chest.width, chest.height);
                    
                    // Lid
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(chest.x - chest.width / 2, chest.y - chest.height / 2, chest.width, 5);
                }
            });
        }
        
        // Render Doors
        function renderDoors() {
            doors.forEach(door => {
                if (door.locked) {
                    ctx.fillStyle = door.color;
                    ctx.fillRect(door.x - door.width / 2, door.y - door.height / 2, door.width, door.height);
                }
            });
        }
        
        // Render Exit Stairs
        function renderExitStairs() {
            if (exitStairs) {
                ctx.fillStyle = exitStairs.color;
                ctx.fillRect(exitStairs.x - exitStairs.width / 2, exitStairs.y - exitStairs.height / 2, exitStairs.width, exitStairs.height);
                
                // Stairs pattern
                ctx.strokeStyle = '#FFA500';
                ctx.lineWidth = 2;
                for (let i = 0; i < 4; i++) {
                    const offset = (i - 1.5) * 8;
                    ctx.beginPath();
                    ctx.moveTo(exitStairs.x - 12, exitStairs.y + offset);
                    ctx.lineTo(exitStairs.x + 12, exitStairs.y + offset);
                    ctx.stroke();
                }
                
                // Glow
                ctx.globalAlpha = 0.3 + Math.sin(frameCount * 0.1) * 0.2;
                ctx.fillStyle = exitStairs.color;
                ctx.beginPath();
                ctx.arc(exitStairs.x, exitStairs.y, 40, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }
        
        // Render Projectiles
        function renderProjectiles() {
            projectiles.forEach(proj => {
                ctx.fillStyle = proj.color;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            
            enemyProjectiles.forEach(proj => {
                ctx.fillStyle = proj.color;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Render Particles
        function renderParticles() {
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.lifetime / 30;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            });
        }
        
        // Render UI
        function renderUI() {
            ctx.textAlign = 'left';
            
            ctx.fillStyle = '#FF0000';
            ctx.font = 'bold 18px Arial';
            ctx.fillText(`HP: ${player.health}/${player.maxHealth}`, 20, 25);
            
            ctx.fillStyle = '#FFD700';
            ctx.fillText(`Floor: ${floor}`, 200, 25);
            
            ctx.fillStyle = '#00FFFF';
            ctx.fillText(`Level: ${player.level}`, 340, 25);
            
            ctx.fillStyle = '#9370DB';
            ctx.fillText(`EXP: ${player.experience}/${player.experienceNeeded}`, 480, 25);
            
            ctx.fillStyle = '#FFD700';
            ctx.fillText(`Gold: ${player.gold}`, 720, 25);
            
            ctx.fillStyle = '#FF1493';
            ctx.fillText(`Potions: ${player.potions}`, 860, 25);
            
            // Instructions
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '12px Arial';
            ctx.fillText('Click to attack | E: Use Potion | Q: Open Chest', 20, canvas.height - 10);
        }
        
        // Render Menu
        function renderMenu() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.textAlign = 'center';
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 60px Arial';
            ctx.fillText('RPG DUNGEON', 500, 150);
            
            ctx.fillStyle = '#CCCCCC';
            ctx.font = '22px Arial';
            ctx.fillText('AI-Generated Game', 500, 200);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = 'bold 30px Arial';
            ctx.fillText('Press SPACE to Start', 500, 300);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '24px Arial';
            ctx.fillText('Controls:', 500, 380);
            
            ctx.fillStyle = '#CCCCCC';
            ctx.font = '18px Arial';
            ctx.fillText('WASD/Arrows: Move | Space: Attack | E: Use Potion | Q: Interact', 500, 420);
            
            ctx.fillStyle = '#FF6600';
            ctx.font = '20px Arial';
            ctx.fillText('Defeat all enemies and find the stairs!', 500, 480);
        }
        
        // Render Level Up
        function renderLevelUp() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.textAlign = 'center';
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 50px Arial';
            ctx.fillText('LEVEL UP!', 500, 250);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = '28px Arial';
            ctx.fillText(`Level ${player.level} | +10 HP | +2 ATK | +1 DEF`, 500, 320);
        }
        
        // Render Victory
        function renderVictory() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.textAlign = 'center';
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 60px Arial';
            ctx.fillText('VICTORY!', 500, 200);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = '32px Arial';
            ctx.fillText("You've conquered the dungeon!", 500, 280);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '28px Arial';
            ctx.fillText(`Final Level: ${player.level}`, 500, 350);
            ctx.fillText(`Final Floor: ${floor}`, 500, 390);
            
            ctx.fillStyle = '#FFD700';
            ctx.fillText(`Gold Collected: ${player.gold}`, 500, 430);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = '24px Arial';
            ctx.fillText('Press R to Restart', 500, 520);
        }
        
        // Render Game Over
        function renderGameOver() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.textAlign = 'center';
            ctx.fillStyle = '#FF0000';
            ctx.font = 'bold 60px Arial';
            ctx.fillText('GAME OVER', 500, 200);
            
            ctx.fillStyle = '#CCCCCC';
            ctx.font = '32px Arial';
            ctx.fillText('You have fallen...', 500, 280);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '28px Arial';
            ctx.fillText(`Final Level: ${player.level}`, 500, 350);
            ctx.fillText(`Floors Cleared: ${floor - 1}`, 500, 390);
            
            ctx.fillStyle = '#FFD700';
            ctx.fillText(`Gold Collected: ${player.gold}`, 500, 430);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = '24px Arial';
            ctx.fillText('Press R to Restart', 500, 520);
        }
        
        // Game Loop
        function gameLoop() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (gameState === 'menu') {
                renderMenu();
            } else if (gameState === 'playing') {
                updatePlayer();
                updateEnemies();
                updateProjectiles();
                updateParticles();
                
                renderDungeon();
                renderExitStairs();
                renderChests();
                renderDoors();
                renderItems();
                renderProjectiles();
                renderEnemies();
                renderPlayer();
                renderParticles();
                renderUI();
            } else if (gameState === 'levelUp') {
                renderDungeon();
                renderExitStairs();
                renderChests();
                renderDoors();
                renderItems();
                renderEnemies();
                renderPlayer();
                renderUI();
                renderLevelUp();
                
                levelUpTimer++;
                if (levelUpTimer >= 90) {
                    gameState = 'playing';
                }
            } else if (gameState === 'victory') {
                renderVictory();
            } else if (gameState === 'gameOver') {
                renderGameOver();
            }
            
            frameCount++;
            requestAnimationFrame(gameLoop);
        }
        
        // Start Game
        initGame();
        gameLoop();
    </script>
</body>
</html>