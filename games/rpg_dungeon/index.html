<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG Dungeon</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #0a0a0a;
            font-family: Arial, sans-serif;
        }
        
        #gameContainer {
            position: relative;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        #game-canvas {
            display: block;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game-canvas" width="1000" height="700"></canvas>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const GRID_SIZE = 40;
        const DUNGEON_ROWS = 15;
        const DUNGEON_COLS = 20;
        const OFFSET_X = 20;
        const OFFSET_Y = 50;
        const TILE_SIZE = 16;
        const SPRITE_SCALE = 2;
        const MAX_FLOOR = 10;
        
        // Game state
        let gameState = 'menu';
        let keys = {};
        let floor = 1;
        let dungeon = [];
        let rooms = [];
        let player = null;
        let enemies = [];
        let projectiles = [];
        let items = [];
        let chests = [];
        let exitStairs = null;
        let levelUpTimer = 0;
        let spriteSheet = null;
        let spriteSheetLoaded = false;
        
        // Load sprite sheet
        const loadSpriteSheet = () => {
            spriteSheet = new Image();
            spriteSheet.src = 'assets/tiny_dungeon_monsters.png';
            spriteSheet.onload = () => {
                spriteSheetLoaded = true;
            };
            spriteSheet.onerror = () => {
                console.warn('Sprite sheet not found, using fallback rendering');
                spriteSheetLoaded = false;
            };
        };
        
        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 12;
                this.speed = 3;
                this.maxHealth = 100;
                this.health = 100;
                this.attack = 20;
                this.defense = 5;
                this.level = 1;
                this.experience = 0;
                this.experienceToNext = 100;
                this.gold = 0;
                this.potions = 3;
                this.attackCooldown = 0;
                this.attackCooldownMax = 30;
                this.facing = 'down';
                this.spritePos = { row: 3, col: 9 };
            }
            
            update() {
                // Movement
                let dx = 0;
                let dy = 0;
                
                if (keys['KeyW'] || keys['ArrowUp']) {
                    dy -= this.speed;
                    this.facing = 'up';
                    this.spritePos = { row: 3, col: 10 };
                }
                if (keys['KeyS'] || keys['ArrowDown']) {
                    dy += this.speed;
                    this.facing = 'down';
                    this.spritePos = { row: 3, col: 9 };
                }
                if (keys['KeyA'] || keys['ArrowLeft']) {
                    dx -= this.speed;
                    this.facing = 'left';
                    this.spritePos = { row: 3, col: 11 };
                }
                if (keys['KeyD'] || keys['ArrowRight']) {
                    dx += this.speed;
                    this.facing = 'right';
                    this.spritePos = { row: 3, col: 8 };
                }
                
                // Try to move and check collision
                const newX = this.x + dx;
                const newY = this.y + dy;
                
                if (!this.checkWallCollision(newX, this.y)) {
                    this.x = newX;
                }
                if (!this.checkWallCollision(this.x, newY)) {
                    this.y = newY;
                }
                
                // Attack
                if (this.attackCooldown > 0) {
                    this.attackCooldown--;
                }
                
                if (keys['Space'] && this.attackCooldown === 0) {
                    this.shoot();
                    this.attackCooldown = this.attackCooldownMax;
                }
                
                // Use potion
                if (keys['KeyE']) {
                    this.usePotion();
                    keys['KeyE'] = false; // Prevent multiple uses
                }
                
                // Interact with chests
                if (keys['KeyQ']) {
                    this.interact();
                    keys['KeyQ'] = false;
                }
                
                // Check item pickups
                this.checkItemPickup();
                
                // Check exit stairs
                this.checkExitStairs();
            }
            
            checkWallCollision(x, y) {
                const gridX = Math.floor((x - OFFSET_X) / GRID_SIZE);
                const gridY = Math.floor((y - OFFSET_Y) / GRID_SIZE);
                
                if (gridX < 0 || gridX >= DUNGEON_COLS || gridY < 0 || gridY >= DUNGEON_ROWS) {
                    return true;
                }
                
                return dungeon[gridY][gridX] === 1;
            }
            
            shoot() {
                let dx = 0;
                let dy = 0;
                
                switch(this.facing) {
                    case 'up': dy = -1; break;
                    case 'down': dy = 1; break;
                    case 'left': dx = -1; break;
                    case 'right': dx = 1; break;
                }
                
                const damage = Math.floor(this.attack * (1 + this.level * 0.1));
                projectiles.push(new Projectile(this.x, this.y, dx, dy, 8, damage, 'player'));
            }
            
            usePotion() {
                if (this.potions > 0 && this.health < this.maxHealth) {
                    this.health = Math.min(this.health + 50, this.maxHealth);
                    this.potions--;
                }
            }
            
            interact() {
                for (let chest of chests) {
                    if (!chest.opened) {
                        const dist = Math.hypot(this.x - chest.x, this.y - chest.y);
                        if (dist < 40) {
                            chest.open(this);
                        }
                    }
                }
            }
            
            checkItemPickup() {
                for (let i = items.length - 1; i >= 0; i--) {
                    const item = items[i];
                    const dist = Math.hypot(this.x - item.x, this.y - item.y);
                    if (dist < this.radius + item.radius) {
                        if (item.type === 'health_potion') {
                            this.potions++;
                            items.splice(i, 1);
                        }
                    }
                }
            }
            
            checkExitStairs() {
                if (exitStairs && enemies.length === 0) {
                    const dist = Math.hypot(this.x - exitStairs.x, this.y - exitStairs.y);
                    if (dist < 50) {
                        if (floor >= MAX_FLOOR) {
                            gameState = 'victory';
                        } else {
                            floor++;
                            generateDungeon();
                        }
                    }
                }
            }
            
            takeDamage(damage) {
                const actualDamage = Math.max(1, damage - this.defense);
                this.health -= actualDamage;
                if (this.health <= 0) {
                    this.health = 0;
                    gameState = 'gameOver';
                }
            }
            
            gainExperience(exp) {
                this.experience += exp;
                if (this.experience >= this.experienceToNext) {
                    this.levelUp();
                }
            }
            
            levelUp() {
                this.level++;
                this.experience -= this.experienceToNext;
                this.experienceToNext = 100 * this.level;
                this.maxHealth += 10;
                this.health = this.maxHealth; // Full heal on level up
                this.attack += 2;
                this.defense += 1;
                gameState = 'levelUp';
                levelUpTimer = 90;
            }
            
            draw() {
                if (spriteSheetLoaded) {
                    const sx = this.spritePos.col * TILE_SIZE;
                    const sy = this.spritePos.row * TILE_SIZE;
                    const size = TILE_SIZE * SPRITE_SCALE;
                    ctx.drawImage(spriteSheet, sx, sy, TILE_SIZE, TILE_SIZE,
                                this.x - size/2, this.y - size/2, size, size);
                } else {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Enemy class
        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.radius = 10;
                this.type = type;
                this.facing = 'down';
                
                const floorMultiplier = 1 + (floor - 1) * 0.2;
                
                if (type === 'slime') {
                    this.name = 'Acid Slime';
                    this.health = Math.floor(30 * floorMultiplier);
                    this.maxHealth = this.health;
                    this.attack = Math.floor(5 * (1 + (floor - 1) * 0.15));
                    this.defense = 2;
                    this.speed = 0.5;
                    this.experience = 20;
                    this.goldDrop = { min: 5, max: 15 };
                    this.color = '#00FF00';
                    this.detectionRange = 200;
                    this.attackRange = 15;
                    this.spritePos = { row: 16, col: 9 };
                } else if (type === 'skeleton') {
                    this.name = 'Deadly Skeleton';
                    this.health = Math.floor(50 * floorMultiplier);
                    this.maxHealth = this.health;
                    this.attack = Math.floor(8 * (1 + (floor - 1) * 0.15));
                    this.defense = 4;
                    this.speed = 1.5;
                    this.experience = 35;
                    this.goldDrop = { min: 10, max: 25 };
                    this.color = '#CCCCCC';
                    this.detectionRange = 200;
                    this.attackRange = 20;
                    this.spritePos = { row: 8, col: 5 };
                } else { // orc
                    this.name = 'Enormous Orc';
                    this.health = Math.floor(80 * floorMultiplier);
                    this.maxHealth = this.health;
                    this.attack = Math.floor(12 * (1 + (floor - 1) * 0.15));
                    this.defense = 6;
                    this.speed = 1.2;
                    this.experience = 50;
                    this.goldDrop = { min: 20, max: 40 };
                    this.color = '#228B22';
                    this.detectionRange = 200;
                    this.attackRange = 40;
                    this.spritePos = { row: 6, col: 1 };
                }
                
                this.attackCooldown = 0;
                this.attackCooldownMax = 60;
            }
            
            update() {
                if (!player) return;
                
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                // Update facing direction
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 0) {
                        this.facing = 'right';
                        if (this.type === 'slime') this.spritePos.col = 8;
                        else if (this.type === 'skeleton') this.spritePos.col = 4;
                        else this.spritePos.col = 0;
                    } else {
                        this.facing = 'left';
                        if (this.type === 'slime') this.spritePos.col = 11;
                        else if (this.type === 'skeleton') this.spritePos.col = 7;
                        else this.spritePos.col = 3;
                    }
                } else {
                    if (dy > 0) {
                        this.facing = 'down';
                        if (this.type === 'slime') this.spritePos.col = 9;
                        else if (this.type === 'skeleton') this.spritePos.col = 5;
                        else this.spritePos.col = 1;
                    } else {
                        this.facing = 'up';
                        if (this.type === 'slime') this.spritePos.col = 10;
                        else if (this.type === 'skeleton') this.spritePos.col = 6;
                        else this.spritePos.col = 2;
                    }
                }
                
                // Chase player if in detection range
                if (dist < this.detectionRange && dist > this.attackRange) {
                    const moveX = (dx / dist) * this.speed;
                    const moveY = (dy / dist) * this.speed;
                    
                    const newX = this.x + moveX;
                    const newY = this.y + moveY;
                    
                    if (!this.checkWallCollision(newX, this.y)) {
                        this.x = newX;
                    }
                    if (!this.checkWallCollision(this.x, newY)) {
                        this.y = newY;
                    }
                }
                
                // Attack player
                if (this.attackCooldown > 0) {
                    this.attackCooldown--;
                }
                
                if (dist < this.attackRange && this.attackCooldown === 0) {
                    player.takeDamage(this.attack);
                    this.attackCooldown = this.attackCooldownMax;
                }
                
                // Ranged attack for skeletons and orcs
                if ((this.type === 'skeleton' || this.type === 'orc') && 
                    dist < 200 && dist > 50 && this.attackCooldown === 0) {
                    const projDx = dx / dist;
                    const projDy = dy / dist;
                    projectiles.push(new Projectile(this.x, this.y, projDx, projDy, 5, this.attack, 'enemy'));
                    this.attackCooldown = this.attackCooldownMax;
                }
            }
            
            checkWallCollision(x, y) {
                const gridX = Math.floor((x - OFFSET_X) / GRID_SIZE);
                const gridY = Math.floor((y - OFFSET_Y) / GRID_SIZE);
                
                if (gridX < 0 || gridX >= DUNGEON_COLS || gridY < 0 || gridY >= DUNGEON_ROWS) {
                    return true;
                }
                
                return dungeon[gridY][gridX] === 1;
            }
            
            takeDamage(damage) {
                const actualDamage = Math.max(1, damage - this.defense);
                this.health -= actualDamage;
                if (this.health <= 0) {
                    this.die();
                }
            }
            
            die() {
                // Drop gold
                const gold = Math.floor(Math.random() * (this.goldDrop.max - this.goldDrop.min + 1)) + this.goldDrop.min;
                player.gold += gold;
                
                // Grant experience
                player.gainExperience(this.experience);
                
                // Chance to drop potion
                if (Math.random() < 0.3) {
                    items.push(new Item(this.x, this.y, 'health_potion'));
                }
                
                // Remove from enemies array
                const index = enemies.indexOf(this);
                if (index > -1) {
                    enemies.splice(index, 1);
                }
            }
            
            draw() {
                if (spriteSheetLoaded) {
                    const sx = this.spritePos.col * TILE_SIZE;
                    const sy = this.spritePos.row * TILE_SIZE;
                    const size = TILE_SIZE * SPRITE_SCALE;
                    ctx.drawImage(spriteSheet, sx, sy, TILE_SIZE, TILE_SIZE,
                                this.x - size/2, this.y - size/2, size, size);
                } else {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Health bar
                const barWidth = 30;
                const barHeight = 4;
                const healthPercent = this.health / this.maxHealth;
                
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(this.x - barWidth/2, this.y - this.radius - 10, barWidth, barHeight);
                ctx.fillStyle = '#00FF00';
                ctx.fillRect(this.x - barWidth/2, this.y - this.radius - 10, barWidth * healthPercent, barHeight);
            }
        }
        
        // Projectile class
        class Projectile {
            constructor(x, y, dx, dy, speed, damage, owner) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.speed = speed;
                this.damage = damage;
                this.owner = owner;
                this.radius = 5;
                this.lifetime = 30;
                this.color = owner === 'player' ? '#FFFF00' : '#FF0000';
            }
            
            update() {
                this.x += this.dx * this.speed;
                this.y += this.dy * this.speed;
                this.lifetime--;
                
                // Check wall collision
                if (this.checkWallCollision()) {
                    this.lifetime = 0;
                }
                
                // Check enemy collision (player projectiles)
                if (this.owner === 'player') {
                    for (let enemy of enemies) {
                        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                        if (dist < this.radius + enemy.radius) {
                            enemy.takeDamage(this.damage);
                            this.lifetime = 0;
                            break;
                        }
                    }
                }
                
                // Check player collision (enemy projectiles)
                if (this.owner === 'enemy' && player) {
                    const dist = Math.hypot(this.x - player.x, this.y - player.y);
                    if (dist < this.radius + player.radius) {
                        player.takeDamage(this.damage);
                        this.lifetime = 0;
                    }
                }
            }
            
            checkWallCollision() {
                const gridX = Math.floor((this.x - OFFSET_X) / GRID_SIZE);
                const gridY = Math.floor((this.y - OFFSET_Y) / GRID_SIZE);
                
                if (gridX < 0 || gridX >= DUNGEON_COLS || gridY < 0 || gridY >= DUNGEON_ROWS) {
                    return true;
                }
                
                return dungeon[gridY][gridX] === 1;
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Item class
        class Item {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = 12;
                this.spritePos = { row: 28, col: 13 };
            }
            
            draw() {
                if (spriteSheetLoaded) {
                    const sx = this.spritePos.col * TILE_SIZE;
                    const sy = this.spritePos.row * TILE_SIZE;
                    const size = TILE_SIZE * SPRITE_SCALE;
                    ctx.drawImage(spriteSheet, sx, sy, TILE_SIZE, TILE_SIZE,
                                this.x - size/2, this.y - size/2, size, size);
                } else {
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Chest class
        class Chest {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 12;
                this.opened = false;
                this.gold = Math.floor(Math.random() * 71) + 30; // 30-100
                this.hasPotion = Math.random() < 0.5;
            }
            
            open(player) {
                if (!this.opened) {
                    this.opened = true;
                    player.gold += this.gold;
                    if (this.hasPotion) {
                        player.potions++;
                    }
                }
            }
            
            draw() {
                if (spriteSheetLoaded) {
                    const spritePos = this.opened ? { row: 23, col: 5 } : { row: 22, col: 5 };
                    const sx = spritePos.col * TILE_SIZE;
                    const sy = spritePos.row * TILE_SIZE;
                    const size = TILE_SIZE * SPRITE_SCALE;
                    ctx.drawImage(spriteSheet, sx, sy, TILE_SIZE, TILE_SIZE,
                                this.x - size/2, this.y - size/2, size, size);
                } else {
                    ctx.fillStyle = this.opened ? '#8B4513' : '#FFD700';
                    ctx.fillRect(this.x - this.radius, this.y - this.radius, 
                               this.radius * 2, this.radius * 2);
                }
            }
        }
        
        // Dungeon generation using BSP
        function generateDungeon() {
            // Reset game entities
            enemies = [];
            projectiles = [];
            items = [];
            chests = [];
            exitStairs = null;
            
            // Initialize dungeon with walls
            dungeon = [];
            for (let y = 0; y < DUNGEON_ROWS; y++) {
                dungeon[y] = [];
                for (let x = 0; x < DUNGEON_COLS; x++) {
                    dungeon[y][x] = 1; // 1 = wall
                }
            }
            
            // Generate rooms using BSP
            rooms = [];
            const rootPartition = {
                x: 0,
                y: 0,
                width: DUNGEON_COLS,
                height: DUNGEON_ROWS
            };
            
            partitionSpace(rootPartition, 0);
            
            // Connect rooms with corridors
            for (let i = 0; i < rooms.length - 1; i++) {
                const room1 = rooms[i];
                const room2 = rooms[i + 1];
                createCorridor(room1, room2);
            }
            
            // Spawn player in first room
            const firstRoom = rooms[0];
            const playerX = (firstRoom.x + firstRoom.width / 2) * GRID_SIZE + OFFSET_X;
            const playerY = (firstRoom.y + firstRoom.height / 2) * GRID_SIZE + OFFSET_Y;
            
            if (!player) {
                player = new Player(playerX, playerY);
            } else {
                player.x = playerX;
                player.y = playerY;
            }
            
            // Spawn enemies in rooms (excluding first room)
            for (let i = 1; i < rooms.length; i++) {
                const room = rooms[i];
                const enemyCount = Math.floor(Math.random() * 3) + 1 + Math.floor(floor * 0.5);
                
                for (let j = 0; j < enemyCount; j++) {
                    const ex = (room.x + 1 + Math.random() * (room.width - 2)) * GRID_SIZE + OFFSET_X;
                    const ey = (room.y + 1 + Math.random() * (room.height - 2)) * GRID_SIZE + OFFSET_Y;
                    
                    const rand = Math.random();
                    let type;
                    if (rand < 0.5) type = 'slime';
                    else if (rand < 0.8) type = 'skeleton';
                    else type = 'orc';
                    
                    enemies.push(new Enemy(ex, ey, type));
                }
            }
            
            // Spawn chests
            const chestCount = Math.floor(Math.random() * 3) + 2;
            for (let i = 0; i < chestCount; i++) {
                const room = rooms[Math.floor(Math.random() * rooms.length)];
                const cx = (room.x + 1 + Math.random() * (room.width - 2)) * GRID_SIZE + OFFSET_X;
                const cy = (room.y + 1 + Math.random() * (room.height - 2)) * GRID_SIZE + OFFSET_Y;
                chests.push(new Chest(cx, cy));
            }
        }
        
        function partitionSpace(partition, depth) {
            if (depth > 3 || partition.width < 8 || partition.height < 8) {
                createRoom(partition);
                return;
            }
            
            const splitHorizontal = Math.random() > 0.5;
            
            if (splitHorizontal && partition.height >= 8) {
                const splitPos = Math.floor(partition.height / 2) + Math.floor(Math.random() * 3) - 1;
                const top = {
                    x: partition.x,
                    y: partition.y,
                    width: partition.width,
                    height: splitPos
                };
                const bottom = {
                    x: partition.x,
                    y: partition.y + splitPos,
                    width: partition.width,
                    height: partition.height - splitPos
                };
                partitionSpace(top, depth + 1);
                partitionSpace(bottom, depth + 1);
            } else if (!splitHorizontal && partition.width >= 8) {
                const splitPos = Math.floor(partition.width / 2) + Math.floor(Math.random() * 3) - 1;
                const left = {
                    x: partition.x,
                    y: partition.y,
                    width: splitPos,
                    height: partition.height
                };
                const right = {
                    x: partition.x + splitPos,
                    y: partition.y,
                    width: partition.width - splitPos,
                    height: partition.height
                };
                partitionSpace(left, depth + 1);
                partitionSpace(right, depth + 1);
            } else {
                createRoom(partition);
            }
        }
        
        function createRoom(partition) {
            const minSize = 3;
            const maxSize = 7;
            
            const width = Math.min(maxSize, Math.max(minSize, Math.floor(Math.random() * (partition.width - 2)) + minSize));
            const height = Math.min(maxSize, Math.max(minSize, Math.floor(Math.random() * (partition.height - 2)) + minSize));
            
            const x = partition.x + Math.floor(Math.random() * (partition.width - width));
            const y = partition.y + Math.floor(Math.random() * (partition.height - height));
            
            const room = { x, y, width, height };
            rooms.push(room);
            
            // Carve out the room
            for (let ry = y; ry < y + height; ry++) {
                for (let rx = x; rx < x + width; rx++) {
                    if (ry >= 0 && ry < DUNGEON_ROWS && rx >= 0 && rx < DUNGEON_COLS) {
                        dungeon[ry][rx] = 0; // 0 = floor
                    }
                }
            }
        }
        
        function createCorridor(room1, room2) {
            const x1 = Math.floor(room1.x + room1.width / 2);
            const y1 = Math.floor(room1.y + room1.height / 2);
            const x2 = Math.floor(room2.x + room2.width / 2);
            const y2 = Math.floor(room2.y + room2.height / 2);
            
            // Create L-shaped corridor
            if (Math.random() > 0.5) {
                // Horizontal then vertical
                for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
                    if (y1 >= 0 && y1 < DUNGEON_ROWS && x >= 0 && x < DUNGEON_COLS) {
                        dungeon[y1][x] = 0;
                    }
                }
                for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
                    if (y >= 0 && y < DUNGEON_ROWS && x2 >= 0 && x2 < DUNGEON_COLS) {
                        dungeon[y][x2] = 0;
                    }
                }
            } else {
                // Vertical then horizontal
                for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
                    if (y >= 0 && y < DUNGEON_ROWS && x1 >= 0 && x1 < DUNGEON_COLS) {
                        dungeon[y][x1] = 0;
                    }
                }
                for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
                    if (y2 >= 0 && y2 < DUNGEON_ROWS && x >= 0 && x < DUNGEON_COLS) {
                        dungeon[y2][x] = 0;
                    }
                }
            }
        }
        
        // Draw functions
        function drawDungeon() {
            for (let y = 0; y < DUNGEON_ROWS; y++) {
                for (let x = 0; x < DUNGEON_COLS; x++) {
                    const px = x * GRID_SIZE + OFFSET_X;
                    const py = y * GRID_SIZE + OFFSET_Y;
                    
                    if (dungeon[y][x] === 1) {
                        ctx.fillStyle = '#2C1810';
                        ctx.fillRect(px, py, GRID_SIZE, GRID_SIZE);
                    } else {
                        ctx.fillStyle = '#4A3728';
                        ctx.fillRect(px, py, GRID_SIZE, GRID_SIZE);
                    }
                }
            }
            
            // Draw exit stairs if all enemies defeated
            if (enemies.length === 0 && !exitStairs) {
                const lastRoom = rooms[rooms.length - 1];
                exitStairs = {
                    x: (lastRoom.x + lastRoom.width / 2) * GRID_SIZE + OFFSET_X,
                    y: (lastRoom.y + lastRoom.height / 2) * GRID_SIZE + OFFSET_Y
                };
            }
            
            if (exitStairs) {
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(exitStairs.x - 15, exitStairs.y - 15, 30, 30);
                ctx.fillStyle = '#000';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('EXIT', exitStairs.x, exitStairs.y + 5);
            }
        }
        
        function drawHUD() {
            ctx.fillStyle = '#FF0000';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`HP: ${player.health}/${player.maxHealth}`, 20, 25);
            
            ctx.fillStyle = '#FFD700';
            ctx.fillText(`Floor: ${floor}`, 200, 25);
            
            ctx.fillStyle = '#00FFFF';
            ctx.fillText(`Level: ${player.level}`, 340, 25);
            
            ctx.fillStyle = '#9370DB';
            ctx.fillText(`EXP: ${player.experience}/${player.experienceToNext}`, 480, 25);
            
            ctx.fillStyle = '#FFD700';
            ctx.fillText(`Gold: ${player.gold}`, 720, 25);
            
            ctx.fillStyle = '#FF1493';
            ctx.fillText(`Potions: ${player.potions}`, 860, 25);
        }
        
        function drawMenu() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('RPG DUNGEON', canvas.width / 2, 150);
            
            ctx.fillStyle = '#CCCCCC';
            ctx.font = '22px Arial';
            ctx.fillText('AI-Generated Game', canvas.width / 2, 200);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = 'bold 30px Arial';
            ctx.fillText('Press S to Start', canvas.width / 2, 300);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = '24px Arial';
            ctx.fillText('Press H for How to Play', canvas.width / 2, 350);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '24px Arial';
            ctx.fillText('Controls:', canvas.width / 2, 430);
            
            ctx.fillStyle = '#CCCCCC';
            ctx.font = '18px Arial';
            ctx.fillText('WASD/Arrows: Move | Space: Attack | E: Use Potion | Q: Interact', canvas.width / 2, 470);
            
            ctx.fillStyle = '#FF6600';
            ctx.font = '20px Arial';
            ctx.fillText('Defeat all enemies and find the stairs!', canvas.width / 2, 530);
            
            // Credits
            ctx.fillStyle = '#888888';
            ctx.font = '14px Arial';
            ctx.fillText('Developer: AI & megadigo (megadigo@gmail.com)', canvas.width / 2, 630);
            ctx.fillText('Contributors: Claude Sonnet 4.5, Graphics Oryx (www.oryxdesignlab.com)', canvas.width / 2, 650);
            ctx.fillText('License: MIT', canvas.width / 2, 670);
        }
        
        function drawHowToPlay() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 50px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('HOW TO PLAY', canvas.width / 2, 60);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('OBJECTIVE', canvas.width / 2, 120);
            
            ctx.fillStyle = '#CCCCCC';
            ctx.font = '18px Arial';
            ctx.fillText('Navigate through 10 procedurally generated dungeon floors.', canvas.width / 2, 155);
            ctx.fillText('Defeat all enemies on each floor to unlock the exit stairs.', canvas.width / 2, 180);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('CONTROLS', canvas.width / 2, 230);
            
            ctx.fillStyle = '#CCCCCC';
            ctx.font = '18px Arial';
            ctx.fillText('WASD or Arrow Keys - Move your hero', canvas.width / 2, 265);
            ctx.fillText('SPACE - Shoot projectiles to attack enemies', canvas.width / 2, 290);
            ctx.fillText('E - Use a health potion to restore 50 HP', canvas.width / 2, 315);
            ctx.fillText('Q - Interact with chests and pick up items', canvas.width / 2, 340);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('GAMEPLAY MECHANICS', canvas.width / 2, 390);
            
            ctx.fillStyle = '#CCCCCC';
            ctx.font = '18px Arial';
            ctx.fillText('• Collect gold from chests and defeated enemies', canvas.width / 2, 425);
            ctx.fillText('• Gain experience to level up and increase your stats', canvas.width / 2, 450);
            ctx.fillText('• Enemies get stronger as you progress through floors', canvas.width / 2, 475);
            ctx.fillText('• Health potions and chests spawn throughout the dungeon', canvas.width / 2, 500);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('TIPS', canvas.width / 2, 550);
            
            ctx.fillStyle = '#CCCCCC';
            ctx.font = '18px Arial';
            ctx.fillText('Use walls for cover and kite enemies with ranged attacks', canvas.width / 2, 585);
            ctx.fillText('Save health potions for tough encounters', canvas.width / 2, 610);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 22px Arial';
            ctx.fillText('Press ESC to Return to Menu', canvas.width / 2, 680);
        }
        
        function drawLevelUp() {
            // Draw game state underneath
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawDungeon();
            chests.forEach(chest => chest.draw());
            items.forEach(item => item.draw());
            enemies.forEach(enemy => enemy.draw());
            projectiles.forEach(proj => proj.draw());
            if (player) player.draw();
            drawHUD();
            
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 50px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('LEVEL UP!', canvas.width / 2, 250);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = '28px Arial';
            ctx.fillText(`Level ${player.level} | +10 HP | +2 ATK | +1 DEF`, canvas.width / 2, 320);
            
            // Update timer
            levelUpTimer--;
            if (levelUpTimer <= 0) {
                gameState = 'playing';
            }
        }
        
        function drawVictory() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('VICTORY!', canvas.width / 2, 200);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = '32px Arial';
            ctx.fillText("You've conquered the dungeon!", canvas.width / 2, 280);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '28px Arial';
            ctx.fillText(`Final Level: ${player.level}`, canvas.width / 2, 350);
            ctx.fillText(`Final Floor: ${floor}`, canvas.width / 2, 390);
            
            ctx.fillStyle = '#FFD700';
            ctx.fillText(`Gold Collected: ${player.gold}`, canvas.width / 2, 430);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = '24px Arial';
            ctx.fillText('Press R to Restart', canvas.width / 2, 520);
        }
        
        function drawGameOver() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#FF0000';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, 200);
            
            ctx.fillStyle = '#CCCCCC';
            ctx.font = '32px Arial';
            ctx.fillText('You have fallen...', canvas.width / 2, 280);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '28px Arial';
            ctx.fillText(`Final Level: ${player.level}`, canvas.width / 2, 350);
            ctx.fillText(`Floors Cleared: ${floor - 1}`, canvas.width / 2, 390);
            
            ctx.fillStyle = '#FFD700';
            ctx.fillText(`Gold Collected: ${player.gold}`, canvas.width / 2, 430);
            
            ctx.fillStyle = '#00FF00';
            ctx.font = '24px Arial';
            ctx.fillText('Press R to Restart', canvas.width / 2, 520);
        }
        
        // Game loop
        function gameLoop() {
            // Clear canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (gameState === 'menu') {
                drawMenu();
            } else if (gameState === 'howToPlay') {
                drawHowToPlay();
            } else if (gameState === 'playing') {
                // Update
                if (player) {
                    player.update();
                }
                enemies.forEach(enemy => enemy.update());
                projectiles.forEach(proj => proj.update());
                projectiles = projectiles.filter(proj => proj.lifetime > 0);
                
                // Draw
                drawDungeon();
                chests.forEach(chest => chest.draw());
                items.forEach(item => item.draw());
                enemies.forEach(enemy => enemy.draw());
                projectiles.forEach(proj => proj.draw());
                if (player) {
                    player.draw();
                    drawHUD();
                }
            } else if (gameState === 'levelUp') {
                drawLevelUp();
            } else if (gameState === 'victory') {
                drawVictory();
            } else if (gameState === 'gameOver') {
                drawGameOver();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Input handling
        function handleKeyDown(e) {
            keys[e.code] = true;
            
            // Prevent default browser behavior for game keys
            if (['KeyW', 'KeyA', 'KeyS', 'KeyD', 'ArrowUp', 'ArrowLeft', 
                 'ArrowDown', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
            
            // Menu state
            if (gameState === 'menu') {
                if (e.code === 'KeyS') {
                    gameState = 'playing';
                    floor = 1;
                    player = null;
                    generateDungeon();
                }
                if (e.code === 'KeyH') {
                    gameState = 'howToPlay';
                }
            }
            
            // How to play state
            if (gameState === 'howToPlay') {
                if (e.code === 'Escape') {
                    gameState = 'menu';
                }
                if (e.code === 'KeyS') {
                    gameState = 'playing';
                    floor = 1;
                    player = null;
                    generateDungeon();
                }
            }
            
            // Victory/GameOver state
            if ((gameState === 'victory' || gameState === 'gameOver') && e.code === 'KeyR') {
                gameState = 'playing';
                floor = 1;
                player = null;
                generateDungeon();
            }
        }
        
        function handleKeyUp(e) {
            keys[e.code] = false;
        }
        
        // Initialize game
        function init() {
            loadSpriteSheet();
            generateDungeon();
            
            // Set up event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Start game loop
            gameLoop();
        }
        
        // Start the game
        init();
    </script>
</body>
</html>
