<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG Dungeon</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #0a0a0a;
            font-family: Arial, sans-serif;
        }
        
        #game-canvas {
            border: 2px solid #333;
            display: block;
            background: #000;
            image-rendering: pixelated;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
    <canvas id="game-canvas" width="1000" height="700"></canvas>

    <script>
        const CANVAS_WIDTH = 1000;
        const CANVAS_HEIGHT = 700;
        const GRID_SIZE = 40;
        const DUNGEON_ROWS = 15;
        const DUNGEON_COLS = 20;
        const DUNGEON_OFFSET_X = 20;
        const DUNGEON_OFFSET_Y = 50;
        const TILE_SIZE = 16;
        
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        // Load sprite sheet
        const spriteSheet = new Image();
        spriteSheet.src = 'assets/tiny_dungeon_monsters.png';
        let spriteLoaded = false;
        spriteSheet.onload = () => { spriteLoaded = true; console.log('Sprites loaded'); };
        spriteSheet.onerror = () => console.error('Failed to load sprites');
        
        // Game state
        let gameState = 'menu';
        let floor = 1;
        let levelUpTimer = 0;
        
        // Input
        const keys = {};
        const pressed = {};
        
        // Entities
        let player, enemies, items, chests, doors, stairs, projectiles, enemyProj, dungeon;
        
        function createPlayer() {
            return {
                x: 0, y: 0, radius: 15, speed: 3, dir: 'down',
                stats: { maxHP: 100, hp: 100, atk: 10, def: 5, lvl: 1, exp: 0, expNext: 100 },
                inv: { gold: 0, potions: 3, keys: 0 },
                atkCD: 0, maxAtkCD: 30
            };
        }
        
        const enemyTypes = {
            slime: { name: "Slime", row: 16, cols: [10,11,12,13], scale: 2, r: 12, col: "#0F0",
                     hp: 30, atk: 5, def: 2, spd: 1, exp: 20, gold: [5,15], range: 50, chase: false, atkRange: 30, atkCD: 60 },
            skeleton: { name: "Skeleton", row: 9, cols: [1,2,3,4], scale: 2, r: 12, col: "#CCC",
                        hp: 50, atk: 8, def: 4, spd: 1.5, exp: 35, gold: [10,25], range: 100, chase: true, atkRange: 20, atkCD: 60 },
            orc: { name: "Orc", row: 13, cols: [6,7,8,9], scale: 2, r: 15, col: "#282",
                   hp: 80, atk: 12, def: 6, spd: 1.2, exp: 50, gold: [20,40], range: 200, chase: true, atkRange: 40, atkCD: 60 }
        };
        
        // BSP Dungeon Gen
        class Room {
            constructor(x, y, w, h) {
                this.x = x; this.y = y; this.w = w; this.h = h;
                this.cx = x + Math.floor(w/2); this.cy = y + Math.floor(h/2);
            }
        }
        
        class BSP {
            constructor(x, y, w, h) {
                this.x = x; this.y = y; this.w = w; this.h = h;
                this.l = null; this.r = null; this.room = null;
            }
            
            split() {
                if (this.l || this.r) return false;
                const horiz = Math.random() > 0.5;
                const max = (horiz ? this.h : this.w) - 6;
                if (max <= 6) return false;
                const s = Math.floor(Math.random() * (max - 6)) + 6;
                if (horiz) {
                    this.l = new BSP(this.x, this.y, this.w, s);
                    this.r = new BSP(this.x, this.y + s, this.w, this.h - s);
                } else {
                    this.l = new BSP(this.x, this.y, s, this.h);
                    this.r = new BSP(this.x + s, this.y, this.w - s, this.h);
                }
                return true;
            }
            
            makeRoom() {
                if (this.l || this.r) {
                    if (this.l) this.l.makeRoom();
                    if (this.r) this.r.makeRoom();
                } else {
                    const rw = Math.floor(Math.random() * 5) + 3;
                    const rh = Math.floor(Math.random() * 5) + 3;
                    const rx = this.x + Math.floor(Math.random() * (this.w - rw));
                    const ry = this.y + Math.floor(Math.random() * (this.h - rh));
                    this.room = new Room(rx, ry, rw, rh);
                }
            }
            
            getRoom() {
                if (this.room) return this.room;
                const lr = this.l ? this.l.getRoom() : null;
                const rr = this.r ? this.r.getRoom() : null;
                if (!lr && !rr) return null;
                if (!rr) return lr;
                if (!lr) return rr;
                return Math.random() > 0.5 ? lr : rr;
            }
        }
        
        function genDungeon() {
            const grid = Array(DUNGEON_ROWS).fill(0).map(() => Array(DUNGEON_COLS).fill(0));
            const root = new BSP(0, 0, DUNGEON_COLS, DUNGEON_ROWS);
            const rooms = [];
            
            let nodes = [root];
            for (let i = 0; i < 4; i++) {
                const newNodes = [];
                for (const n of nodes) {
                    if (n.split()) { newNodes.push(n.l, n.r); } else { newNodes.push(n); }
                }
                nodes = newNodes;
            }
            
            root.makeRoom();
            
            function collect(n) {
                if (n.room) rooms.push(n.room);
                if (n.l) collect(n.l);
                if (n.r) collect(n.r);
            }
            collect(root);
            
            for (const rm of rooms) {
                for (let y = rm.y; y < rm.y + rm.h; y++) {
                    for (let x = rm.x; x < rm.x + rm.w; x++) {
                        if (x >= 0 && x < DUNGEON_COLS && y >= 0 && y < DUNGEON_ROWS) {
                            grid[y][x] = 1;
                        }
                    }
                }
            }
            
            for (let i = 0; i < rooms.length - 1; i++) {
                const r1 = rooms[i], r2 = rooms[i + 1];
                if (Math.random() > 0.5) {
                    for (let x = Math.min(r1.cx, r2.cx); x <= Math.max(r1.cx, r2.cx); x++) {
                        if (x >= 0 && x < DUNGEON_COLS && r1.cy >= 0 && r1.cy < DUNGEON_ROWS) grid[r1.cy][x] = 1;
                    }
                    for (let y = Math.min(r1.cy, r2.cy); y <= Math.max(r1.cy, r2.cy); y++) {
                        if (r2.cx >= 0 && r2.cx < DUNGEON_COLS && y >= 0 && y < DUNGEON_ROWS) grid[y][r2.cx] = 1;
                    }
                } else {
                    for (let y = Math.min(r1.cy, r2.cy); y <= Math.max(r1.cy, r2.cy); y++) {
                        if (r1.cx >= 0 && r1.cx < DUNGEON_COLS && y >= 0 && y < DUNGEON_ROWS) grid[y][r1.cx] = 1;
                    }
                    for (let x = Math.min(r1.cx, r2.cx); x <= Math.max(r1.cx, r2.cx); x++) {
                        if (x >= 0 && x < DUNGEON_COLS && r2.cy >= 0 && r2.cy < DUNGEON_ROWS) grid[r2.cy][x] = 1;
                    }
                }
            }
            
            return { grid, rooms };
        }
        
        function findDoors(grid) {
            const doorPos = [];
            for (let y = 1; y < DUNGEON_ROWS - 1; y++) {
                for (let x = 1; x < DUNGEON_COLS - 1; x++) {
                    if (grid[y][x] === 1) {
                        const t = grid[y-1][x], b = grid[y+1][x], l = grid[y][x-1], r = grid[y][x+1];
                        if (l === 0 && r === 0 && t === 1 && b === 1) {
                            const tt = y > 1 ? grid[y-2][x] : 0, bb = y < DUNGEON_ROWS - 2 ? grid[y+2][x] : 0;
                            if ((tt === 0 || bb === 0) && doorPos.length < 3) doorPos.push({ x, y, ori: 'v' });
                        } else if (t === 0 && b === 0 && l === 1 && r === 1) {
                            const ll = x > 1 ? grid[y][x-2] : 0, rr = x < DUNGEON_COLS - 2 ? grid[y][x+2] : 0;
                            if ((ll === 0 || rr === 0) && doorPos.length < 3) doorPos.push({ x, y, ori: 'h' });
                        }
                    }
                }
            }
            return doorPos;
        }
        
        function init() {
            player = createPlayer();
            enemies = []; items = []; chests = []; doors = []; projectiles = []; enemyProj = []; stairs = null;
            floor = 1;
            genLevel();
        }
        
        function genLevel() {
            const dg = genDungeon();
            dungeon = dg.grid;
            const rooms = dg.rooms;
            
            enemies = []; items = []; chests = []; doors = []; projectiles = []; enemyProj = []; stairs = null;
            
            player.x = DUNGEON_OFFSET_X + rooms[0].cx * GRID_SIZE;
            player.y = DUNGEON_OFFSET_Y + rooms[0].cy * GRID_SIZE;
            
            const dps = findDoors(dungeon);
            for (let i = 0; i < Math.min(3, dps.length); i++) {
                doors.push({
                    gx: dps[i].x, gy: dps[i].y,
                    x: DUNGEON_OFFSET_X + dps[i].x * GRID_SIZE + GRID_SIZE/2,
                    y: DUNGEON_OFFSET_Y + dps[i].y * GRID_SIZE + GRID_SIZE/2,
                    ori: dps[i].ori, locked: true
                });
            }
            
            for (let i = 0; i < 3; i++) {
                const rm = rooms[Math.floor(Math.random() * (rooms.length - 1)) + 1];
                items.push({ type: 'key', x: DUNGEON_OFFSET_X + (rm.x + Math.random() * rm.w) * GRID_SIZE,
                            y: DUNGEON_OFFSET_Y + (rm.y + Math.random() * rm.h) * GRID_SIZE, r: 6, col: "#FD0" });
            }
            
            for (let i = 1; i < rooms.length; i++) {
                const rm = rooms[i];
                const ec = Math.floor(Math.random() * 3) + 1;
                for (let j = 0; j < ec; j++) {
                    const types = ['slime', 'skeleton', 'orc'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    const t = enemyTypes[type];
                    enemies.push({
                        ...t, x: DUNGEON_OFFSET_X + (rm.x + Math.random() * rm.w) * GRID_SIZE,
                        y: DUNGEON_OFFSET_Y + (rm.y + Math.random() * rm.h) * GRID_SIZE,
                        maxHP: t.hp * Math.pow(1.2, floor - 1), hp: t.hp * Math.pow(1.2, floor - 1),
                        atk: t.atk * Math.pow(1.15, floor - 1), dir: 'down', timer: 0
                    });
                }
            }
            
            for (let i = 0; i < Math.floor(Math.random() * 3) + 2; i++) {
                const rm = rooms[Math.floor(Math.random() * (rooms.length - 1)) + 1];
                chests.push({ x: DUNGEON_OFFSET_X + (rm.x + Math.random() * rm.w) * GRID_SIZE,
                             y: DUNGEON_OFFSET_Y + (rm.y + Math.random() * rm.h) * GRID_SIZE,
                             w: 20, h: 15, opened: false, gold: Math.floor(Math.random() * 70) + 30,
                             potion: Math.random() < 0.5 });
            }
            
            for (let i = 0; i < 2; i++) {
                const rm = rooms[Math.floor(Math.random() * (rooms.length - 1)) + 1];
                items.push({ type: 'potion', x: DUNGEON_OFFSET_X + (rm.x + Math.random() * rm.w) * GRID_SIZE,
                            y: DUNGEON_OFFSET_Y + (rm.y + Math.random() * rm.h) * GRID_SIZE, r: 8, col: "#F00" });
            }
        }
        
        function checkStairs() {
            if (enemies.length === 0 && !stairs) {
                const tiles = [];
                for (let y = 0; y < DUNGEON_ROWS; y++) {
                    for (let x = 0; x < DUNGEON_COLS; x++) {
                        if (dungeon[y][x] === 1) {
                            tiles.push({ x: x * GRID_SIZE + DUNGEON_OFFSET_X, y: y * GRID_SIZE + DUNGEON_OFFSET_Y });
                        }
                    }
                }
                let maxD = 0, farthest = null;
                for (const t of tiles) {
                    const d = Math.hypot(t.x - player.x, t.y - player.y);
                    if (d > maxD) { maxD = d; farthest = t; }
                }
                if (farthest) stairs = { x: farthest.x + GRID_SIZE/2, y: farthest.y + GRID_SIZE/2, w: 30, h: 30 };
            }
        }
        
        function isWall(x, y) {
            const gx = Math.floor((x - DUNGEON_OFFSET_X) / GRID_SIZE);
            const gy = Math.floor((y - DUNGEON_OFFSET_Y) / GRID_SIZE);
            if (gx < 0 || gx >= DUNGEON_COLS || gy < 0 || gy >= DUNGEON_ROWS) return true;
            return dungeon[gy][gx] === 0;
        }
        
        function checkDoor(x, y) {
            for (const d of doors) {
                if (!d.locked) continue;
                if (d.ori === 'h') {
                    if (Math.abs(x - d.x) < 5 && Math.abs(y - d.y) < GRID_SIZE/2) return true;
                } else {
                    if (Math.abs(y - d.y) < 5 && Math.abs(x - d.x) < GRID_SIZE/2) return true;
                }
            }
            return false;
        }
        
        function update() {
            if (gameState === 'menu') {
                if (pressed['Space']) { init(); gameState = 'playing'; }
            } else if (gameState === 'playing') {
                updateGame();
            } else if (gameState === 'levelUp') {
                levelUpTimer--;
                if (levelUpTimer <= 0) gameState = 'playing';
            } else if (gameState === 'victory' || gameState === 'gameOver') {
                if (pressed['KeyR']) { init(); gameState = 'playing'; }
            }
            for (const k in pressed) pressed[k] = false;
        }
        
        function updateGame() {
            let dx = 0, dy = 0;
            if (keys['KeyW'] || keys['ArrowUp']) { dy = -1; player.dir = 'up'; }
            if (keys['KeyS'] || keys['ArrowDown']) { dy = 1; player.dir = 'down'; }
            if (keys['KeyA'] || keys['ArrowLeft']) { dx = -1; player.dir = 'left'; }
            if (keys['KeyD'] || keys['ArrowRight']) { dx = 1; player.dir = 'right'; }
            
            if (dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }
            
            const nx = player.x + dx * player.speed;
            const ny = player.y + dy * player.speed;
            if (!isWall(nx, player.y) && !checkDoor(nx, player.y)) player.x = nx;
            if (!isWall(player.x, ny) && !checkDoor(player.x, ny)) player.y = ny;
            
            if (player.atkCD > 0) player.atkCD--;
            
            if (pressed['Space'] && player.atkCD === 0) {
                player.atkCD = player.maxAtkCD;
                let pdx = 0, pdy = 0;
                if (player.dir === 'up') pdy = -1;
                else if (player.dir === 'down') pdy = 1;
                else if (player.dir === 'left') pdx = -1;
                else if (player.dir === 'right') pdx = 1;
                projectiles.push({ x: player.x, y: player.y, dx: pdx * 8, dy: pdy * 8, r: 5, life: 30,
                                  dmg: player.stats.atk * (1 + (player.stats.lvl - 1) * 0.1) });
            }
            
            if (pressed['KeyE'] && player.inv.potions > 0 && player.stats.hp < player.stats.maxHP) {
                player.inv.potions--;
                player.stats.hp = Math.min(player.stats.maxHP, player.stats.hp + 50);
            }
            
            if (pressed['KeyQ']) {
                for (const c of chests) {
                    if (!c.opened && Math.hypot(player.x - c.x, player.y - c.y) < 30) {
                        c.opened = true;
                        player.inv.gold += c.gold;
                        if (c.potion) player.inv.potions++;
                    }
                }
                for (const d of doors) {
                    if (d.locked && player.inv.keys > 0 && Math.hypot(player.x - d.x, player.y - d.y) < 30) {
                        d.locked = false;
                        player.inv.keys--;
                    }
                }
            }
            
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.dx; p.y += p.dy; p.life--;
                if (p.life <= 0 || isWall(p.x, p.y)) { projectiles.splice(i, 1); continue; }
                
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (Math.hypot(p.x - e.x, p.y - e.y) < e.r + p.r) {
                        e.hp -= Math.max(1, p.dmg - e.def);
                        if (e.hp <= 0) {
                            player.stats.exp += e.exp;
                            player.inv.gold += Math.floor(Math.random() * (e.gold[1] - e.gold[0] + 1)) + e.gold[0];
                            enemies.splice(j, 1);
                            
                            if (player.stats.exp >= player.stats.expNext) {
                                player.stats.lvl++;
                                player.stats.exp -= player.stats.expNext;
                                player.stats.expNext = 100 * player.stats.lvl;
                                player.stats.maxHP += 10;
                                player.stats.hp = player.stats.maxHP;
                                player.stats.atk += 2;
                                player.stats.def += 1;
                                levelUpTimer = 90;
                                gameState = 'levelUp';
                            }
                        }
                        projectiles.splice(i, 1);
                        break;
                    }
                }
            }
            
            for (const e of enemies) {
                const dist = Math.hypot(player.x - e.x, player.y - e.y);
                const edx = player.x - e.x, edy = player.y - e.y;
                if (Math.abs(edx) > Math.abs(edy)) e.dir = edx > 0 ? 'right' : 'left';
                else e.dir = edy > 0 ? 'down' : 'up';
                
                if (e.chase && dist < e.range) {
                    const ang = Math.atan2(player.y - e.y, player.x - e.x);
                    const enx = e.x + Math.cos(ang) * e.spd;
                    const eny = e.y + Math.sin(ang) * e.spd;
                    if (!isWall(enx, e.y)) e.x = enx;
                    if (!isWall(e.x, eny)) e.y = eny;
                }
                
                if (e.timer > 0) e.timer--;
                if (dist < e.atkRange && e.timer === 0) {
                    e.timer = e.atkCD;
                    const ang = Math.atan2(player.y - e.y, player.x - e.x);
                    enemyProj.push({ x: e.x, y: e.y, dx: Math.cos(ang) * 5, dy: Math.sin(ang) * 5, r: 5, life: 30, dmg: e.atk });
                }
            }
            
            for (let i = enemyProj.length - 1; i >= 0; i--) {
                const p = enemyProj[i];
                p.x += p.dx; p.y += p.dy; p.life--;
                if (p.life <= 0 || isWall(p.x, p.y)) { enemyProj.splice(i, 1); continue; }
                
                if (Math.hypot(p.x - player.x, p.y - player.y) < player.radius + p.r) {
                    player.stats.hp -= Math.max(1, p.dmg - player.stats.def);
                    if (player.stats.hp <= 0) gameState = 'gameOver';
                    enemyProj.splice(i, 1);
                }
            }
            
            for (let i = items.length - 1; i >= 0; i--) {
                const it = items[i];
                if (Math.hypot(player.x - it.x, player.y - it.y) < player.radius + it.r) {
                    if (it.type === 'key') player.inv.keys++;
                    else if (it.type === 'potion') player.inv.potions++;
                    items.splice(i, 1);
                }
            }
            
            checkStairs();
            if (stairs && Math.hypot(player.x - stairs.x, player.y - stairs.y) < 30) {
                floor++;
                if (floor > 10) gameState = 'victory';
                else genLevel();
            }
        }
        
        function drawSprite(ent, x, y) {
            if (!spriteLoaded) {
                ctx.fillStyle = ent.col;
                ctx.beginPath();
                ctx.arc(x, y, ent.r, 0, Math.PI * 2);
                ctx.fill();
                return;
            }
            
            let col;
            const dirIdx = { right: 0, down: 1, up: 2, left: 3 };
            col = ent.cols[dirIdx[ent.dir] || 1];
            
            const sx = col * TILE_SIZE;
            const sy = ent.row * TILE_SIZE;
            const sz = TILE_SIZE * ent.scale;
            
            ctx.drawImage(spriteSheet, sx, sy, TILE_SIZE, TILE_SIZE, x - sz/2, y - sz/2, sz, sz);
        }
        
        function render() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            if (gameState === 'menu') {
                ctx.fillStyle = "#1a1a1a";
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                ctx.fillStyle = "#FFD700";
                ctx.font = "bold 60px Arial";
                ctx.textAlign = "center";
                ctx.fillText("RPG DUNGEON", CANVAS_WIDTH/2, 150);
                
                ctx.fillStyle = "#CCC";
                ctx.font = "22px Arial";
                ctx.fillText("AI-Generated Game", CANVAS_WIDTH/2, 200);
                
                ctx.fillStyle = "#0F0";
                ctx.font = "bold 30px Arial";
                ctx.fillText("Press SPACE to Start", CANVAS_WIDTH/2, 300);
                
                ctx.fillStyle = "#FFF";
                ctx.font = "24px Arial";
                ctx.fillText("Controls:", CANVAS_WIDTH/2, 380);
                
                ctx.fillStyle = "#CCC";
                ctx.font = "18px Arial";
                ctx.fillText("WASD/Arrows: Move | Space: Attack | E: Potion | Q: Interact", CANVAS_WIDTH/2, 420);
                
                ctx.fillStyle = "#F60";
                ctx.font = "20px Arial";
                ctx.fillText("Defeat all enemies and find the stairs!", CANVAS_WIDTH/2, 480);
            } else if (gameState === 'playing' || gameState === 'levelUp') {
                ctx.fillStyle = "#000";
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                for (let y = 0; y < DUNGEON_ROWS; y++) {
                    for (let x = 0; x < DUNGEON_COLS; x++) {
                        ctx.fillStyle = dungeon[y][x] === 1 ? "#4A3728" : "#2C1810";
                        ctx.fillRect(DUNGEON_OFFSET_X + x * GRID_SIZE, DUNGEON_OFFSET_Y + y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    }
                }
                
                for (const d of doors) {
                    ctx.fillStyle = d.locked ? "#8B4513" : "#4A3728";
                    if (d.ori === 'h') ctx.fillRect(d.x - 3, d.y - GRID_SIZE/2, 6, GRID_SIZE);
                    else ctx.fillRect(d.x - GRID_SIZE/2, d.y - 3, GRID_SIZE, 6);
                }
                
                if (stairs) {
                    ctx.fillStyle = "#FFD700";
                    ctx.fillRect(stairs.x - stairs.w/2, stairs.y - stairs.h/2, stairs.w, stairs.h);
                }
                
                for (const it of items) {
                    ctx.fillStyle = it.col;
                    ctx.beginPath();
                    ctx.arc(it.x, it.y, it.r, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                for (const c of chests) {
                    ctx.fillStyle = c.opened ? "#654321" : "#8B4513";
                    ctx.fillRect(c.x - c.w/2, c.y - c.h/2, c.w, c.h);
                }
                
                for (const p of projectiles) {
                    ctx.fillStyle = "#FF0";
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                for (const p of enemyProj) {
                    ctx.fillStyle = "#F00";
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                for (const e of enemies) {
                    drawSprite(e, e.x, e.y);
                    const bw = 30, bh = 4, hpct = e.hp / e.maxHP;
                    ctx.fillStyle = "#F00";
                    ctx.fillRect(e.x - bw/2, e.y - e.r * e.scale - 10, bw, bh);
                    ctx.fillStyle = "#0F0";
                    ctx.fillRect(e.x - bw/2, e.y - e.r * e.scale - 10, bw * hpct, bh);
                }
                
                const pSprite = { row: 4, cols: [9,10,11,12], scale: 2, r: player.radius, col: "#00F", dir: player.dir };
                drawSprite(pSprite, player.x, player.y);
                
                ctx.textAlign = "left";
                ctx.fillStyle = "#F00";
                ctx.font = "bold 18px Arial";
                ctx.fillText(`HP: ${Math.floor(player.stats.hp)}/${player.stats.maxHP}`, 20, 25);
                
                ctx.fillStyle = "#FD0";
                ctx.fillText(`Floor: ${floor}`, 200, 25);
                
                ctx.fillStyle = "#0FF";
                ctx.fillText(`Level: ${player.stats.lvl}`, 340, 25);
                
                ctx.fillStyle = "#93D";
                ctx.fillText(`EXP: ${Math.floor(player.stats.exp)}/${player.stats.expNext}`, 480, 25);
                
                ctx.fillStyle = "#FD0";
                ctx.fillText(`Gold: ${player.inv.gold}`, 720, 25);
                
                ctx.fillStyle = "#F49";
                ctx.fillText(`Potions: ${player.inv.potions}`, 860, 25);
                
                ctx.fillStyle = "#FD0";
                ctx.fillText(`Keys: ${player.inv.keys}`, 20, CANVAS_HEIGHT - 10);
                
                if (gameState === 'levelUp') {
                    ctx.fillStyle = "rgba(0,0,0,0.5)";
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    
                    ctx.fillStyle = "#FFD700";
                    ctx.font = "bold 50px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText("LEVEL UP!", CANVAS_WIDTH/2, 250);
                    
                    ctx.fillStyle = "#0F0";
                    ctx.font = "28px Arial";
                    ctx.fillText(`Level ${player.stats.lvl} | +10 HP | +2 ATK | +1 DEF`, CANVAS_WIDTH/2, 320);
                }
            } else if (gameState === 'victory') {
                ctx.fillStyle = "#1a1a1a";
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                ctx.fillStyle = "#FFD700";
                ctx.font = "bold 60px Arial";
                ctx.textAlign = "center";
                ctx.fillText("VICTORY!", CANVAS_WIDTH/2, 200);
                
                ctx.fillStyle = "#0F0";
                ctx.font = "32px Arial";
                ctx.fillText("You've conquered the dungeon!", CANVAS_WIDTH/2, 280);
                
                ctx.fillStyle = "#FFF";
                ctx.font = "28px Arial";
                ctx.fillText(`Final Level: ${player.stats.lvl}`, CANVAS_WIDTH/2, 350);
                ctx.fillText(`Final Floor: ${floor}`, CANVAS_WIDTH/2, 390);
                
                ctx.fillStyle = "#FD0";
                ctx.fillText(`Gold Collected: ${player.inv.gold}`, CANVAS_WIDTH/2, 430);
                
                ctx.fillStyle = "#0F0";
                ctx.font = "24px Arial";
                ctx.fillText("Press R to Restart", CANVAS_WIDTH/2, 520);
            } else if (gameState === 'gameOver') {
                ctx.fillStyle = "#1a1a1a";
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                ctx.fillStyle = "#F00";
                ctx.font = "bold 60px Arial";
                ctx.textAlign = "center";
                ctx.fillText("GAME OVER", CANVAS_WIDTH/2, 200);
                
                ctx.fillStyle = "#CCC";
                ctx.font = "32px Arial";
                ctx.fillText("You have fallen...", CANVAS_WIDTH/2, 280);
                
                ctx.fillStyle = "#FFF";
                ctx.font = "28px Arial";
                ctx.fillText(`Final Level: ${player.stats.lvl}`, CANVAS_WIDTH/2, 350);
                ctx.fillText(`Floors Cleared: ${floor - 1}`, CANVAS_WIDTH/2, 390);
                
                ctx.fillStyle = "#FD0";
                ctx.fillText(`Gold Collected: ${player.inv.gold}`, CANVAS_WIDTH/2, 430);
                
                ctx.fillStyle = "#0F0";
                ctx.font = "24px Arial";
                ctx.fillText("Press R to Restart", CANVAS_WIDTH/2, 520);
            }
        }
        
        document.addEventListener('keydown', e => {
            if (!pressed[e.code]) pressed[e.code] = true;
            keys[e.code] = true;
        });
        
        document.addEventListener('keyup', e => { keys[e.code] = false; });
        
        function loop() {
            update();
            render();
            requestAnimationFrame(loop);
        }
        
        loop();
    </script>
</body>
</html>
